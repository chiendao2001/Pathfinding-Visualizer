{"version":3,"sources":["components/node/triangletwo-right.svg","components/node/triangletwo-left.svg","components/node/triangletwo-up.svg","components/node/triangletwo-down.svg","components/node/circle.svg","components/node/Node.jsx","components/algorithms/pathfinding/Dijkstra.js","components/algorithms/pathfinding/A*.js","components/algorithms/pathfinding/Bfs.js","components/algorithms/pathfinding/Dfs.js","components/algorithms/mazes/Recursive.js","components/algorithms/mazes/Prim.js","components/nav/button/Mazes.jsx","components/nav/button/Pathfinding.jsx","components/nav/button/Visualize.jsx","components/nav/button/Clear.jsx","components/nav/button/Reset.jsx","components/nav/Nav.jsx","components/Animations.js","components/guide/Guide.jsx","components/Visualizer.jsx","components/App.jsx","index.js"],"names":["Node","props","id","row","col","className","onMouseDown","onMouseUp","onMouseEnter","isArrow","isStart","class","src","direction","right","left","down","up","alt","isFinish","finish","updateAdjacentNodes","node","graph","adjacentNodes","getAdjacentNodes","adjacentNode","distance","previous","X","Y","results","isWall","push","length","filter","visited","getAllNodes","grid","nodes","sortNodes","sort","a","b","getShortestPath","startNode","endNode","Number","MAX_VALUE","path","current","unshift","calculateEstimatedDistance","estimatedDistance","Math","abs","calculateTotalDistance","totalDistance","depthFirstSearch","visitedNodesInOrder","recursiveDivide","startRow","endRow","startCol","endCol","height","width","verticalDivide","horizontalDivide","round","random","wallIndex","floor","isThrough","i","gateIndex","getNeighbors","neighbors","Maze","type","disabled","data-bs-toggle","aria-expanded","onClick","findNewMaze","Pathfinding","setAlgorithm","Visualize","isDisabled","algorithm","removeVisitedNodes","visitedNodes","visualize","Clear","removeWalls","Reset","reset","Nav","animatePath","pathSpeed","pathLength","document","getElementById","classList","add","childNodes","setTimeout","drawPath","endNodeOnGrid","chooseArrow","nearEndNode","nearEndNodeOnGrid","removeChild","previousNode","drawVisitedNodes","elem","createElement","appendChild","drawMaze","mazeSpeed","HEIGHT","WIDTH","drawBorder","j","Guide","useState","step","setStep","headers","leads","guides","generateHeaders","generateLead","Object","entries","map","guide","generateGuide","finishGuide","prev","Visualizer","setGrid","isPressed","setIsPressed","previousWall","setPreviousWall","startButton","setStartButton","finishButton","setFinishButton","isPathFound","setIsPathFound","setIsDisabled","setStartRow","setStartCol","finishRow","setFinishRow","finishCol","setFinishCol","setVisitedNodes","isGuideFinished","setIsGuideFinished","documentElement","clientWidth","clientHeight","console","log","useEffect","createGrid","handleMouseDown","newGrid","isStartNode","isEndNode","classes","contains","remove","handleMouseEnter","newStartRow","newFinishRow","newVisitedNodes","newPreviousWall","newStartNode","newEndNode","runPathfindingAlgorithm","forEach","newPath","handleMouseUp","unvisitedNodes","minNode","shift","aStar","dijkstra","callStack","breadthFirstSearch","createNode","Array","fill","item","index","getElementsByClassName","circle","moveNodeFromBorder","newStartCol","newFinishCol","setBorderToWall","randomRow","randomCol","frontier","isConnected","isFront","removedIndex","neighbor","splice","nodesToFrontier","nodeIndex","nodesToConnect","randomNeighbor","nodeToConnect","Prim","setAlgorithmName","newName","nodeSpeed","animateNodes","App","ReactDOM","render"],"mappings":"kOAAe,G,MAAA,IAA0B,+CCA1B,MAA0B,6CCA1B,MAA0B,2CCA1B,MAA0B,6CCA1B,MAA0B,mC,OCwB1BA,EAjBF,SAAAC,GAOT,OAAQ,sBAAKC,GAAE,UAAOD,EAAME,IAAb,YAAoBF,EAAMG,KAC7BC,UAAY,OACZC,YAAe,kBAAML,EAAMK,YAAYL,EAAME,IAAKF,EAAMG,MACxDG,UAAa,kBAAMN,EAAMM,aACzBC,aAAgB,kBAAMP,EAAMO,aAAaP,EAAME,IAAKF,EAAMG,MAJ9D,WAKMH,EAAMQ,SAAWR,EAAMS,UAAa,qBAAKC,MAAQ,mBAAmBC,IAVtD,UAApBX,EAAMY,UAA8BC,EAChB,SAApBb,EAAMY,UAA6BE,EACf,SAApBd,EAAMY,UAA6BG,EAChCC,EAO6FC,IAAI,QAC9FjB,EAAMkB,WAAalB,EAAMQ,SAAa,qBAAKJ,UAAY,cAAcO,IAAMQ,EAAQF,IAAI,YCkBnGG,EAAsB,SAACC,EAAMC,GAC/B,IADyC,EACnCC,EAAgBC,EAAiBH,EAAMC,GADJ,cAEdC,GAFc,IAEzC,2BAA0C,CAAC,IAAhCE,EAA+B,QACtCA,EAAaC,SAAWL,EAAKK,SAAW,EACxCD,EAAaE,SAAWN,GAJa,gCASvCG,EAAmB,SAACH,EAAMC,GAC5B,IAAMM,EAAIP,EAAKnB,IACT2B,EAAIR,EAAKlB,IACT2B,EAAU,GAKhB,OAJIF,EAAI,GAAKP,EAAKK,SAAWJ,EAAMM,EAAE,GAAGC,GAAGH,WAAaJ,EAAMM,EAAE,GAAGC,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,EAAE,GAAGC,IAClGD,EAAIN,EAAMW,OAAS,GAAKZ,EAAKK,SAAWJ,EAAMM,EAAE,GAAGC,GAAGH,WAAaJ,EAAMM,EAAE,GAAGC,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,EAAE,GAAGC,IACjHA,EAAI,GAAKR,EAAKK,SAAWJ,EAAMM,GAAGC,EAAE,GAAGH,WAAaJ,EAAMM,GAAGC,EAAE,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,GAAGC,EAAE,IAClGA,EAAIP,EAAM,GAAGW,OAAS,GAAKZ,EAAKK,SAAWJ,EAAMM,GAAGC,EAAE,GAAGH,WAAaJ,EAAMM,GAAGC,EAAE,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,GAAGC,EAAE,IACjHC,EAAQI,QAAO,SAAAb,GAAI,OAAKA,EAAKc,YAIlCC,EAAc,SAAAC,GAChB,IADwB,EAClBC,EAAQ,GADU,cAEND,GAFM,IAExB,2BAAwB,CAAC,IAAD,EAAbnC,EAAa,sBACDA,GADC,IACpB,gCAAWmB,EAAX,QAAwBiB,EAAMN,KAAKX,IADf,gCAFA,8BAKxB,OAAOiB,GAILC,EAAY,SAAAD,GAAK,OAAIA,EAAME,MAAK,SAACC,EAAEC,GAAH,OAASD,EAAEf,SAAWgB,EAAEhB,aAGjDiB,EAAkB,SAACC,EAAWC,GACvC,GAAyB,OAArBA,EAAQlB,WAAyC,IAApBkB,EAAQV,SAAqBU,EAAQnB,WAAaoB,OAAOC,UACtF,OAAO,KAIX,IAFA,IAAMC,EAAO,GACTC,EAAUJ,EAEVG,EAAKE,QAAQD,GACTA,IAAYL,GAChBK,EAAUA,EAAQtB,SAEtB,OAAOqB,GCxCLG,EAA6B,SAAC9B,EAAMwB,GAAP,OAC/BxB,EAAK+B,kBAAoBC,KAAKC,IAAIjC,EAAKnB,IAAM2C,EAAQ3C,KAAOmD,KAAKC,IAAIjC,EAAKlB,IAAM0C,EAAQ1C,MAGtFoD,EAAyB,SAAAlC,GAAI,OAAIA,EAAKmC,cAAgBnC,EAAKK,SAAWL,EAAK+B,mBAG3Eb,EAAY,SAAAD,GAAK,OAAIA,EAAME,MAAK,SAACC,EAAEC,GAAH,OAClCD,EAAEe,cAAgBd,EAAEc,gBAAkB,EAAIf,EAAEW,kBAAoBV,EAAEU,kBACxBX,EAAEe,cAAgBd,EAAEc,kBAE5DpC,EAAsB,SAACC,EAAMC,GAC/B,IADyC,EACnCC,EAAgBC,EAAiBH,EAAMC,GADJ,cAEdC,GAFc,IAEzC,2BAA0C,CAAC,IAAhCE,EAA+B,QACtCA,EAAaC,SAAWL,EAAKK,SAAW,EACxC6B,EAAuB9B,GACvBA,EAAaE,SAAWN,GALa,gCAUvCG,EAAmB,SAACH,EAAMC,GAC5B,IAAMM,EAAIP,EAAKnB,IACT2B,EAAIR,EAAKlB,IACT2B,EAAU,GAKhB,OAJIF,EAAI,GAAKP,EAAKK,SAAWJ,EAAMM,EAAE,GAAGC,GAAGH,WAAaJ,EAAMM,EAAE,GAAGC,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,EAAE,GAAGC,IAClGD,EAAIN,EAAMW,OAAS,GAAKZ,EAAKK,SAAWJ,EAAMM,EAAE,GAAGC,GAAGH,WAAaJ,EAAMM,EAAE,GAAGC,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,EAAE,GAAGC,IACjHA,EAAI,GAAKR,EAAKK,SAAWJ,EAAMM,GAAGC,EAAE,GAAGH,WAAaJ,EAAMM,GAAGC,EAAE,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,GAAGC,EAAE,IAClGA,EAAIP,EAAM,GAAGW,OAAS,GAAKZ,EAAKK,SAAWJ,EAAMM,GAAGC,EAAE,GAAGH,WAAaJ,EAAMM,GAAGC,EAAE,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,GAAGC,EAAE,IACjHC,EAAQI,QAAO,SAAAb,GAAI,OAAKA,EAAKc,YAGlCC,EAAc,SAAAC,GAChB,IADwB,EAClBC,EAAQ,GADU,cAEND,GAFM,IAExB,2BAAwB,CAAC,IAAD,EAAbnC,EAAa,sBACDA,GADC,IACpB,gCAAWmB,EAAX,QAAwBiB,EAAMN,KAAKX,IADf,gCAFA,8BAKxB,OAAOiB,G,OCpDLd,EAAkB,SAACH,EAAMC,GAC3B,IAAMM,EAAIP,EAAKnB,IACT2B,EAAIR,EAAKlB,IACT2B,EAAU,GAKhB,OAJIF,EAAI,IAAMN,EAAMM,EAAE,GAAGC,GAAGM,UAAYb,EAAMM,EAAE,GAAGC,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,EAAE,GAAGC,IAClFA,EAAIP,EAAM,GAAGW,OAAS,IAAMX,EAAMM,GAAGC,EAAE,GAAGM,UAAYb,EAAMM,GAAGC,EAAE,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,GAAGC,EAAE,IACpGD,EAAIN,EAAMW,OAAS,IAAMX,EAAMM,EAAE,GAAGC,GAAGM,UAAYb,EAAMM,EAAE,GAAGC,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,EAAE,GAAGC,IACjGA,EAAI,IAAMP,EAAMM,GAAGC,EAAE,GAAGM,UAAYb,EAAMM,GAAGC,EAAE,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,GAAGC,EAAE,IAC/EC,EAAQI,QAAO,SAAAb,GAAI,OAAKA,EAAKc,YCnC3BsB,EAAmB,SAAnBA,EAAoBnC,EAAOsB,EAAWC,GAC/CD,EAAUlB,SAAW,EACrBkB,EAAUT,SAAU,EACpB,IAAIuB,EAAsB,CAACd,GACrBrB,EAAgBC,EAAiBoB,EAAWtB,GAClD,GAA6B,IAAzBC,EAAcU,QAAgBW,IAAcC,EAAS,OAAOa,EALL,oBAMxCnC,GANwC,IAM3D,2BAAkC,CAAC,IAAxBF,EAAuB,QAK9B,GAJAqC,EAAmB,sBAAOA,GAAP,YAA+BD,EAAiBnC,EAAOD,EAAMwB,KAChFxB,EAAKM,SAAWiB,EAChBvB,EAAKK,SAAWkB,EAAUlB,SAAW,EAEjCgC,EADQA,EAAoBzB,OACJ,KAAOY,EAAS,OAXW,8BAa3D,OAAOa,GAILlC,EAAkB,SAACH,EAAMC,GAC3B,IAAMM,EAAIP,EAAKnB,IACT2B,EAAIR,EAAKlB,IACT2B,EAAU,GAKhB,OAJIF,EAAI,IAAMN,EAAMM,EAAE,GAAGC,GAAGM,UAAYb,EAAMM,EAAE,GAAGC,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,EAAE,GAAGC,IAClFA,EAAIP,EAAM,GAAGW,OAAS,IAAMX,EAAMM,GAAGC,EAAE,GAAGM,UAAYb,EAAMM,GAAGC,EAAE,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,GAAGC,EAAE,IACpGD,EAAIN,EAAMW,OAAS,IAAMX,EAAMM,EAAE,GAAGC,GAAGM,UAAYb,EAAMM,EAAE,GAAGC,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,EAAE,GAAGC,IACjGA,EAAI,IAAMP,EAAMM,GAAGC,EAAE,GAAGM,UAAYb,EAAMM,GAAGC,EAAE,GAAGE,QAAQD,EAAQE,KAAKV,EAAMM,GAAGC,EAAE,IAC/EC,EAAQI,QAAO,SAAAb,GAAI,OAAKA,EAAKc,YCzB1BwB,EAAkB,SAACrC,EAAOsC,EAAUC,EAAQC,EAAUC,GAChE,IAAMC,EAASH,EAASD,EAAW,EAC7BK,EAAQF,EAASD,EAAW,EAClC,KAAKG,EAAQ,GAAKD,EAAS,GAAiB,IAAVC,GAA0B,IAAXD,GAEjD,GAAIC,EAAQD,EAAQE,EAAe5C,EAAOsC,EAAUC,EAAQC,EAAUC,QAEjE,GAAIE,EAAQD,EAAQG,EAAiB7C,EAAOsC,EAAUC,EAAQC,EAAUC,OAExE,CACsBV,KAAKe,MAAMf,KAAKgB,UACtBF,EAAiB7C,EAAOsC,EAAUC,EAAQC,EAAUC,GACpDG,EAAe5C,EAAOsC,EAAUC,EAAQC,EAAUC,KAIrEI,EAAmB,SAAC7C,EAAOsC,EAAUC,EAAQC,EAAUC,GACzD,IAAMC,EAASH,EAASD,EAAW,EAC7BK,EAAQF,EAASD,EAAW,EAE9BQ,EAAYjB,KAAKkB,MAAMlB,KAAKgB,UAAYL,EAAS,IAAMJ,EAAW,EAClEI,EAAS,IAAGM,EAAYjB,KAAKkB,MAAMlB,KAAKgB,UAAYL,EAAO,IAAMJ,EAAW,GAIhF,IAAIY,GAAY,EACXT,EAASzC,EAAM,GAAGW,OAAS,IAAMX,EAAMgD,GAAWP,EAAS,GAAGhC,QAC5DT,EAAMgD,GAAWP,GAAQtD,SAAWa,EAAMgD,GAAWP,GAAQ7C,SAAUsD,GAAY,EACrFlD,EAAMgD,GAAWP,GAAQhC,QAAS,EAElC+B,EAAW,IAAMxC,EAAMgD,GAAWR,EAAW,GAAG/B,QAC9CT,EAAMgD,GAAWR,GAAUrD,SAAWa,EAAMgD,GAAWR,GAAU5C,SAAUsD,GAAY,EACzFlD,EAAMgD,GAAWR,GAAU/B,QAAS,EAEzC,IAAK,IAAI0C,EAAIX,EAAW,EAAGW,EAAIV,EAAQU,IAC/BnD,EAAMgD,GAAWG,GAAGhE,SAAWa,EAAMgD,GAAWG,GAAGvD,SACnDsD,GAAY,EACTlD,EAAMgD,GAAWG,GAAG1C,QAAS,EAExC,IAAKyC,EAAW,CACZ,IAAME,EAAYrB,KAAKkB,MAAMlB,KAAKgB,SAAWJ,GAASH,EACtDxC,EAAMgD,GAAWI,GAAW3C,QAAS,EAGzC4B,EAAgBrC,EAAOsC,EAAUU,EAAY,EAAGR,EAAUC,GAC1DJ,EAAgBrC,EAAOgD,EAAY,EAAGT,EAAQC,EAAUC,IAGtDG,EAAiB,SAAC5C,EAAOsC,EAAUC,EAAQC,EAAUC,GACvD,IAAMC,EAASH,EAASD,EAAW,EAC7BK,EAAQF,EAASD,EAAW,EAE9BQ,EAAYjB,KAAKkB,MAAMlB,KAAKgB,UAAYJ,EAAQ,IAAMH,EAAW,EACjEG,EAAQ,IAAGK,EAAYjB,KAAKkB,MAAMlB,KAAKgB,UAAYJ,EAAM,IAAMH,EAAW,GAE9E,IAAIU,GAAY,EACXZ,EAAW,IAAMtC,EAAMsC,EAAW,GAAGU,GAAWvC,QAC9CT,EAAMsC,GAAUU,GAAW7D,SAAWa,EAAMsC,GAAUU,GAAWpD,SAAUsD,GAAY,EACzFlD,EAAMsC,GAAUU,GAAWvC,QAAS,EACpC8B,EAASvC,EAAMW,OAAS,IAAMX,EAAMuC,EAAS,GAAGS,GAAWvC,QACzDT,EAAMuC,GAAQS,GAAW7D,SAAWa,EAAMuC,GAAQS,GAAWpD,SAAUsD,GAAY,EACrFlD,EAAMuC,GAAQS,GAAWvC,QAAS,EAGvC,IAAK,IAAI0C,EAAIb,EAAW,EAAGa,EAAIZ,EAAQY,IAC/BnD,EAAMmD,GAAGH,GAAW7D,SAAWa,EAAMmD,GAAGH,GAAWpD,SAAUsD,GAAY,EACxElD,EAAMmD,GAAGH,GAAWvC,QAAS,EAEjCyC,IAEDlD,EADkB+B,KAAKkB,MAAMlB,KAAKgB,SAAWL,GAAUJ,GACtCU,GAAWvC,QAAS,GAIzC4B,EAAgBrC,EAAOsC,EAAUC,EAAQC,EAAUQ,EAAY,GAC/DX,EAAgBrC,EAAMsC,EAAUC,EAAQS,EAAY,EAAGP,ICfrDY,EAAe,SAACrD,EAAOD,GACzB,IAAMnB,EAAMmB,EAAKnB,IACXC,EAAMkB,EAAKlB,IACXyE,EAAY,GAOlB,OANI1E,EAAM,GAAK,GAAG0E,EAAU5C,KAAKV,EAAMpB,EAAM,GAAGC,IAC5CD,EAAM,EAAIoB,EAAMW,QAChB2C,EAAU5C,KAAKV,EAAMpB,EAAM,GAAGC,IAE9BA,EAAM,GAAK,GAAGyE,EAAU5C,KAAKV,EAAMpB,GAAKC,EAAM,IAC9CA,EAAM,EAAImB,EAAM,GAAGW,QAAQ2C,EAAU5C,KAAKV,EAAMpB,GAAKC,EAAM,IACxDyE,GCjDIC,G,KAnBF,SAAA7E,GACT,OACI,sBAAKU,MAAM,YAAX,UACI,wBAAQoE,KAAK,SACLC,SAAY/E,EAAM+E,SAClBrE,MAAO,yCACPsE,iBAAe,WACfC,gBAAc,QAJtB,mBAOA,qBAAIvE,MAAM,gBAAV,UACI,oBAAIA,MAAM,gBAAgBwE,QAAW,kBAAMlF,EAAMmF,YAAY,SAA7D,kBACA,oBAAIzE,MAAM,gBAAgBwE,QAAW,kBAAMlF,EAAMmF,YAAY,cAA7D,yCCUDC,EAxBK,SAAApF,GAChB,OACI,sBAAKU,MAAM,YAAX,UACI,wBAAQoE,KAAK,SAASpE,MAAM,kCAAkCsE,iBAAe,WAAWC,gBAAc,QAAtG,wBAGA,qBAAIvE,MAAM,gBAAV,UACI,oBAAIA,MAAM,gBAAgBwE,QAAW,kBAAMlF,EAAMqF,aAAa,OAA9D,0BAGA,oBAAI3E,MAAM,gBAAgBwE,QAAW,kBAAMlF,EAAMqF,aAAa,aAA9D,kCAGA,oBAAI3E,MAAM,gBAAgBwE,QAAW,kBAAMlF,EAAMqF,aAAa,yBAA9D,kCAGA,oBAAI3E,MAAQ,gBAAgBwE,QAAW,kBAAMlF,EAAMqF,aAAa,uBAAhE,uCCDDC,EAbG,SAAAtF,GACd,OACI,wBAAQ8E,KAAK,SACLpE,MAAK,cAAUV,EAAMuF,YAAyC,IAA3BvF,EAAMwF,UAAUvD,OAAe,MAAQ,eAC1E8C,SAAY/E,EAAMuF,YAAyC,IAA3BvF,EAAMwF,UAAUvD,OAChDiD,QAAW,WACHlF,EAAMyF,mBAAmBzF,EAAM0F,cAC/B1F,EAAM2F,aALtB,SAMoC,IAA3B3F,EAAMwF,UAAUvD,OAAe,oBAA/B,oBAAkEjC,EAAMwF,UAAxE,Q,OCEFI,EAVD,SAAA5F,GAAU,IAAD,EACnB,OACI,2BAAQU,MAAQ,SAASoE,KAAK,UAA9B,oCACmB9E,EAAMuF,WAAa,MAAQ,gBAD9C,yBAEgBvF,EAAMuF,YAFtB,yBAGe,kBAAMvF,EAAM6F,iBAH3B,4CCUOC,EAZD,SAAA9F,GACV,OACI,wBAAQ8E,KAAM,SACNpE,MAAK,uBAAmBV,EAAMuF,WAAa,MAAQ,eACnDR,SAAY/E,EAAMuF,WAClBL,QAAW,WACPlF,EAAM+F,SAJlB,yBCsBOC,EApBH,SAAAhG,GACR,OACI,sBAAKU,MAAO,gCAAZ,UACI,qBAAKA,MAAM,+BAAX,oCAGA,cAAC,EAAD,CAAMqE,SAAY/E,EAAMuF,WAAYJ,YAAenF,EAAMmF,cACzD,cAAC,EAAD,CAAaE,aAAgBrF,EAAMqF,eACnC,cAAC,EAAD,CAAYI,mBAAsBzF,EAAMyF,mBAC5BF,WAAcvF,EAAMuF,WACpBC,UAAaxF,EAAMwF,UACnBG,UAAa3F,EAAM2F,UACnBD,aAAgB1F,EAAM0F,eAClC,cAAC,EAAD,CAAOH,WAAcvF,EAAMuF,WAAYM,YAAe7F,EAAM6F,cAC5D,cAAC,EAAD,CAAQN,WAAcvF,EAAMuF,WACpBQ,MAAS/F,EAAM+F,YCD7BE,EAAc,SAACjD,EAAMkD,GACvB,IAAMC,EAAanD,EAAKf,OAClBW,EAAYwD,SAASC,eAAT,UAA2BrD,EAAK,GAAG9C,IAAnC,YAA0C8C,EAAK,GAAG7C,MACpEyC,EAAU0D,UAAUC,IAAI,QACpBvD,EAAK,GAAG9C,IAAM8C,EAAK,GAAG9C,IAAK0C,EAAU4D,WAAW,GAAG7F,IAAMI,EACpDiC,EAAK,GAAG9C,IAAM8C,EAAK,GAAG9C,IAAK0C,EAAU4D,WAAW,GAAG7F,IAAMK,EACzDgC,EAAK,GAAG7C,IAAM6C,EAAK,GAAG7C,IAAKyC,EAAU4D,WAAW,GAAG7F,IAAME,EACzDmC,EAAK,GAAG9C,IAAM8C,EAAK,GAAG9C,MAAK0C,EAAU4D,WAAW,GAAG7F,IAAMG,GAElE,IATqC,eAS5B2D,GACLgC,YAAW,WACPC,EAAS1D,EAAKyB,MACfyB,EAAYzB,IAHVA,EAAI,EAAGA,EAAI0B,EAAa,EAAG1B,IAAM,EAAjCA,GAKT,IAAM5B,EAAUG,EAAKmD,EAAa,GAC5BQ,EAAgBP,SAASC,eAAT,UAA2BxD,EAAQ3C,IAAnC,YAA0C2C,EAAQ1C,MACxEsG,YAAW,WACPE,EAAcL,UAAUC,IAAI,QAC5BI,EAAcH,WAAW,GAAG7F,IAAMiG,EAAY/D,EAAQlB,SAAUkB,GAChE,IAAMgE,EAAchE,EAAQlB,SACtBmF,EAAoBV,SAASC,eAAT,UAA2BQ,EAAY3G,IAAvC,YAA8C2G,EAAY1G,MACpF2G,EAAkBC,YAAYD,EAAkBN,WAAW,MAC5DN,GAAaC,EAAa,KAIpBS,EAAc,SAACI,EAAc3F,GACtB+E,SAASC,eAAT,UAA2BhF,EAAKnB,IAAhC,YAAuCmB,EAAKlB,MAC5D,OAAIkB,EAAKnB,IAAM8G,EAAa9G,IAAYa,EACpCM,EAAKnB,IAAM8G,EAAa9G,IAAYc,EACpCK,EAAKlB,IAAM6G,EAAa7G,IAAYU,EACjCC,GAGEmG,EAAmB,SAAA5F,GAC5B+E,SAASC,eAAT,UAA2BhF,EAAKnB,IAAhC,YAAuCmB,EAAKlB,MAAOmG,UAAUC,IAAI,YAIxDG,EAAW,SAAArF,GACpB+E,SAASC,eAAT,UAA2BhF,EAAKnB,IAAhC,YAAuCmB,EAAKlB,MAAOmG,UAAUC,IAAI,QACjE,IAAMW,EAAOd,SAASe,cAAc,OAIpC,GAHAD,EAAK9G,UAAY,QACjB8G,EAAKvG,IAAMiG,EAAYvF,EAAKM,SAAUN,GACtC+E,SAASC,eAAT,UAA2BhF,EAAKnB,IAAhC,YAAuCmB,EAAKlB,MAAOiH,YAAYF,IAC1D7F,EAAKM,SAASlB,QAAS,CACxB,IAAMuG,EAAeZ,SAASC,eAAT,UAA2BhF,EAAKM,SAASzB,IAAzC,YAAgDmB,EAAKM,SAASxB,MACnF6G,EAAaD,YAAYC,EAAaR,WAAW,MA8B5Ca,EAAW,SAAChF,EAAMiF,GAC3B,IAAMC,EAASlF,EAAKJ,OACduF,EAAQnF,EAAK,GAAGJ,QA3BP,SAACI,EAAMiF,GAGtB,IAFA,IAAMC,EAASlF,EAAKJ,OACduF,EAAQnF,EAAK,GAAGJ,OAFc,WAG3BwC,GACLgC,YAAW,WACPL,SAASC,eAAT,UAA2B5B,EAA3B,YAAgC+C,EAAQ,IAAKlB,UAAUC,IAAI,UAE5De,GAAaE,EAAQ/C,IACxBgC,YAAW,WACPL,SAASC,eAAT,UAA2BkB,EAAQ,EAAI9C,EAAvC,OAA8C6B,UAAUC,IAAI,UAC7De,GAAa,EAAIE,EAAQD,EAAS9C,KAPhCA,EAAI,EAAGA,EAAI8C,EAAQ9C,IAAM,EAAzBA,GAUT,IAboC,eAa3BA,GACLpC,EAAKkF,EAAS,GAAG9C,GAAG1C,QAAS,EAC7B0E,YAAW,WACPL,SAASC,eAAT,YAA6B5B,IAAK6B,UAAUC,IAAI,UACjDe,EAAY7C,GACfgC,YAAW,WACPL,SAASC,eAAT,UAA2BkB,EAAO,EAAlC,YAAuCC,EAAQ,EAAI/C,IAAK6B,UAAUC,IAAI,UACvEe,GAAaC,EAASC,EAAQ/C,KAP5BA,EAAI,EAAGA,EAAI+C,EAAO/C,IAAM,EAAxBA,GAeTgD,CAAWpF,EAAMiF,GACjBb,YAAW,WACP,IADc,IAAD,WACJhC,GACL,IAFS,eAEAiD,GACArF,EAAKoC,GAAGiD,GAAG3F,QACX0E,YAAW,WACPL,SAASC,eAAT,UAA2B5B,EAA3B,YAAgCiD,IAAKpB,UAAUC,IAAI,UACpDe,GAAaI,EAAIrF,EAAKJ,OAASwC,KAJlCiD,EAAI,EAAGA,EAAIrF,EAAKoC,GAAGxC,OAAS,EAAGyF,IAAM,EAArCA,IADJjD,EAAI,EAAGA,EAAIpC,EAAKJ,OAAS,EAAGwC,IAAO,EAAnCA,MAST+C,EAAQD,GAAUD,EAAY,ICtBvBK,G,MAtFD,SAAA3H,GAAU,IAAD,EACK4H,mBAAS,GADd,mBACZC,EADY,KACNC,EADM,KAGbC,EAAU,CACI,qCACA,eACA,oBACA,mBACA,sBACA,kBACA,sBACA,sBACA,+BAAgC,YAG9CC,EAAQ,CACV,uDACA,mGACA,uDACA,+CACA,qDACA,kEACA,gGACA,2DACA,yDACA,6EAGEC,EAAU,CACI,0HACA,4GACA,oIACA,CACI,SAAU,8GACV,SAAY,yDACZ,uBAAwB,iEACxB,qBAAsB,gEAE1B,6IACA,yIACA,6HACA,0IACA,qJACA,0JAepB,OACI,sBAAK7H,UAAY,QAAjB,UACI,mBAAGA,UAAY,QAAf,mBAA2ByH,EAAO,EAAlC,YAAuCE,EAAQ9F,UAd/B,SAAA4F,GAAI,OAAI,oBAAIzH,UAAY,UAAhB,SAA2B2H,EAAQF,KAe1DK,CAAgBL,GAbJ,SAAAA,GAAI,OAAI,mBAAGzH,UAAY,QAAf,SAAwB4H,EAAMH,KAclDM,CAAaN,GAZA,SAAAA,GAClB,MAA4B,kBAAjBI,EAAOJ,GAA2B,mBAAGzH,UAAY,SAAf,SAAyB6H,EAAOJ,KACtEO,OAAOC,QAAQJ,EAAOJ,IAAOS,KAAI,SAAAC,GAAK,OAC7C,sBAAKnI,UAAY,SAAjB,UACI,8BAAImI,EAAM,GAAV,OADJ,IACwBA,EAAM,SASzBC,CAAcX,GACf,wBAAQ/C,KAAM,SACN1E,UAAW,uBACX8E,QAAW,kBAAMlF,EAAMyI,eAF/B,kBAKCZ,EAAOE,EAAQ9F,OAAS,EAAO,wBAAQ6C,KAAO,SACR1E,UAAU,uBACV8E,QAAW,kBAAM4C,GAAQ,SAAAY,GAAI,OAAIA,EAAO,MAF/C,kBAKA,wBAAQ5D,KAAM,SACN1E,UAAW,uBACX8E,QAAW,kBAAMlF,EAAMyI,eAF/B,oBAK/BZ,EAAO,GAAK,wBAAQ/C,KAAO,SACPI,QAAW,kBAAM4C,GAAQ,SAAAY,GAAI,OAAIA,EAAO,MACxCtI,UAAU,2BAFlB,2BC2SVuI,G,MA/WI,WAAO,IAAD,EACGf,mBAAS,CAAC,KADb,mBACdvF,EADc,KACRuG,EADQ,OAGahB,oBAAS,GAHtB,mBAGdiB,EAHc,KAGHC,EAHG,OAKmBlB,mBAAS,MAL5B,mBAKdmB,EALc,KAKAC,EALA,OAOiBpB,oBAAS,GAP1B,mBAOdqB,EAPc,KAODC,EAPC,OAQmBtB,oBAAS,GAR5B,mBAQduB,EARc,KAQAC,EARA,OAUiBxB,oBAAS,GAV1B,mBAUdyB,EAVc,KAUDC,EAVC,OAYa1B,mBAAS,IAZtB,mBAYdpC,EAZc,KAYHH,EAZG,QAgBeuC,oBAAS,GAhBxB,qBAgBdrC,GAhBc,MAgBFgE,GAhBE,SAkBW3B,mBAAS,GAlBpB,qBAkBdhE,GAlBc,MAkBJ4F,GAlBI,SAmBW5B,mBAAS,GAnBpB,qBAmBd9D,GAnBc,MAmBJ2F,GAnBI,SAoBa7B,mBAAS,GApBtB,qBAoBd8B,GApBc,MAoBHC,GApBG,SAqBc/B,mBAAS,GArBvB,qBAqBdgC,GArBc,MAqBHC,GArBG,SAuBmBjC,mBAAS,IAvB5B,qBAuBdlC,GAvBc,MAuBAoE,GAvBA,SAyByBlC,oBAAS,GAzBlC,qBAyBdmC,GAzBc,MAyBGC,GAzBH,MA2BjBxC,GAAQnE,KAAKkB,MAAM6B,SAAS6D,gBAAgBC,YAAY,IAEtD1C,GAAQ,IAAIA,IAAS,GAE3B,IAAID,GAASlE,KAAKkB,MAAM6B,SAAS6D,gBAAgBE,aAAa,IAExD5C,GAAS,IAAIA,IAAU,GAM7B6C,QAAQC,IAAIjE,SAAS6D,gBAAgBC,YAAY,IAEjDI,qBAAU,kBAAM1B,EAAQ2B,QAAc,IAEtC,IAAMC,GAAkB,SAACtK,EAAKC,GAC1B,IAAIsK,EAAUpI,EAGRqI,EAAcxK,IAAQ0D,IAAYzD,IAAQ2D,GAC1C6G,EAAYzK,IAAQwJ,IAAavJ,IAAQyJ,GAI/C,KAAMc,GAAeC,GAAapF,IAAa,CAC3C,IAAMqF,EAAUxE,SAASC,eAAT,UAA2BnG,EAA3B,YAAkCC,IAAOmG,UACzDsE,EAAQC,SAAS,QAAUD,EAAQE,OAAO,QAAUF,EAAQrE,IAAI,QAChEkE,EAAQvK,GAAKC,GAAK4B,QAAU0I,EAAQvK,GAAKC,GAAK4B,OAElD+G,IAAe4B,GAAeC,GAAapF,KAG3C2D,GAAe,SAAAR,GACX,OAAIA,GACgBtC,SAASC,eAAT,UAA2BnG,EAA3B,YAAkCC,IAAOmG,UACjDwE,OAAO,QACfL,EAAQvK,GAAKC,GAAK4B,QAAS,GACnB2G,GAEJgC,IAAgBnF,MAI5B6D,GAAgB,SAAAV,GACZ,OAAIA,GACgBtC,SAASC,eAAT,UAA2BnG,EAA3B,YAAkCC,IAAOmG,UACjDwE,OAAO,QACfL,EAAQvK,GAAKC,GAAK4B,QAAS,GACnB2G,GAEJiC,IAAcpF,MAG1BqD,EAAQ6B,GACRlB,IAvBoB,GAwBpBP,EAAgB,OAGd+B,GAAmB,SAAC7K,EAAKC,GAE3B,IAAIsK,EAAUpI,EACRqI,EAAcxK,IAAQ0D,IAAYzD,IAAQ2D,GAC1C6G,EAAYzK,IAAQwJ,IAAavJ,IAAQyJ,GAG/C,GAAIf,IAAe6B,IAAeC,EAAY,CAC1C,IAAMC,EAAUxE,SAASC,eAAT,UAA2BnG,EAA3B,YAAkCC,IAAOmG,UACzDsE,EAAQC,SAAS,QAAUD,EAAQE,OAAO,QAAUF,EAAQrE,IAAI,QAChEkE,EAAQvK,GAAKC,GAAK4B,QAAU0I,EAAQvK,GAAKC,GAAK4B,OAIlD,IAAMiJ,EAAc/B,IAAgB0B,EAAYzK,EAAM0D,GAEtD6F,GADoBR,IAAgB0B,EAAaxK,EAAM2D,IAEvD0F,GAAYwB,GACRP,EAAQ,GAAGxI,OAAS,IAAMwI,EAAQvK,GAAKC,GAAKM,UAC5CgK,EAAQ7G,IAAUE,IAAUrD,UAAYwI,IAAgB0B,GACxDF,EAAQvK,GAAKC,GAAKM,QAAUwI,IAAgB0B,GAIhD,IAAMM,EAAe9B,IAAiBuB,EAAcxK,EAAMwJ,GAE1DG,GADqBV,IAAiBuB,EAAcvK,EAAMyJ,IAE1DD,GAAasB,GACTR,EAAQ,GAAGxI,OAAS,IAAMwI,EAAQvK,GAAKC,GAAKe,WAC5CuJ,EAAQf,IAAWE,IAAW1I,WAAaiI,IAAiBuB,GAC5DD,EAAQvK,GAAKC,GAAKe,SAAWiI,IAAiBuB,GAIlD,IAAIQ,EAAkBxF,GACtB,GAAIuD,GAAeE,EAAc,CAC7B,IAAIgC,EAAkB,KAWtB,GAVoB,MAAhBpC,IACAA,EAAahH,QAAS,EACtBqE,SAASC,eAAT,UAA2B0C,EAAa7I,IAAxC,YAA+C6I,EAAa5I,MAAOmG,UAAUC,IAAI,SAEjFkE,EAAQvK,GAAKC,GAAK4B,SAClBoJ,EAAkBV,EAAQvK,GAAKC,GAC/BiG,SAASC,eAAT,UAA2BnG,EAA3B,YAAkCC,IAAOmG,UAAUwE,OAAO,QAC1DL,EAAQvK,GAAKC,GAAK4B,QAAS,GAE/BiH,EAAgBmC,GACZ9B,EAAa,CAIb,IAAI+B,EACAC,EAHJH,EAAkBzF,GAAmByF,GAIrCT,EAAQf,IAAWE,IAAWpJ,SAAU,EACxC4K,EAAenC,EAAcwB,EAAQvK,GAAKC,GAAOsK,EAAQ7G,IAAUE,IACnEuH,EAAapC,EAAcwB,EAAQf,IAAWE,IAAaa,EAAQvK,GAAKC,IACxE+K,EAAmBI,GAAwBb,EAASW,EAAcC,IAClDE,SAAQ,SAAAlK,GAAI,OAAI4F,EAAiB5F,MACjD,IAAMmK,EAAU7I,EAAgByI,EAAcC,GAC9C,GAAgB,OAAZG,EAAkB,CAClBA,EAAQD,SAAQ,SAAAlK,GACZ+E,SAASC,eAAT,UAA2BhF,EAAKnB,IAAhC,YAAuCmB,EAAKlB,MAAOmG,UAAUC,IAAI,WAGjEiF,EAAQ,GAAGtL,IAAMsL,EAAQ,GAAGtL,IAAKsL,EAAQ,GAAG5K,UAAY,OACnD4K,EAAQ,GAAGtL,IAAMsL,EAAQ,GAAGtL,IAAKsL,EAAQ,GAAG5K,UAAY,KACxD4K,EAAQ,GAAGrL,IAAMqL,EAAQ,GAAGrL,IAAKqL,EAAQ,GAAG5K,UAAY,QACxD4K,EAAQ,GAAGrL,IAAMqL,EAAQ,GAAGrL,MAAKqL,EAAQ,GAAG5K,UAAY,QAEjE,IAAMiC,EAAU2I,EAAQA,EAAQvJ,OAAS,GACnC4E,EAAchE,EAAQlB,SAC5BkB,EAAQrC,SAAU,EACdqC,EAAQ3C,IAAM2G,EAAY3G,IAAK2C,EAAQjC,UAAY,OAC9CiC,EAAQ3C,IAAM2G,EAAY3G,IAAK2C,EAAQjC,UAAY,KACnDiC,EAAQ1C,IAAM0G,EAAY1G,IAAK0C,EAAQjC,UAAY,QACnDiC,EAAQ1C,IAAM0G,EAAY1G,MAAK0C,EAAQjC,UAAY,UAIxEkJ,GAAgBoB,GAChBtC,EAAQ6B,IAINhF,GAAqB,SAAAC,GAYvB,OAXAA,EAAa6F,SACT,SAAAlK,GACI,IAAMuJ,EAAUxE,SAASC,eAAT,UAA2BhF,EAAKnB,IAAhC,YAAuCmB,EAAKlB,MAAOmG,UACnEsE,EAAQE,OAAO,WACfF,EAAQE,OAAO,WAEvBpF,EAAa6F,SAAQ,SAAAlK,GACjBA,EAAKc,SAAW,EAChBd,EAAKK,SAAWoB,OAAOC,UACvB1B,EAAKM,SAAW,QAEb,IAGL8J,GAAgB,WAClB3C,GAAa,IAIXwC,GAA0B,SAACjJ,EAAMO,EAAWC,GAC9C,MAAkB,OAAd2C,Eb7MS,SAAClE,EAAOsB,EAAWC,GACpCD,EAAUlB,SAAW,EACrB,IAFgD,EAE1CgK,EAAiBtJ,EAAYd,GAC7BoC,EAAsB,GAHoB,cAI9BpC,GAJ8B,IAIhD,2BAAyB,CAAC,IAAD,EAAdpB,EAAc,sBACFA,GADE,IACrB,2BAAwB,CAAC,IAAdmB,EAAa,QACpB8B,EAA2B9B,EAAMwB,GACjCU,EAAuBlC,IAHN,gCAJuB,8BAUhD,KAAOqK,EAAezJ,OAAS,GAAG,CAC9BM,EAAUmJ,GAEV,IAAMC,EAAUD,EAAeE,QAE/B,GAAID,EAAQnI,gBAAkBV,OAAOC,UAAW,CAAC,IAAD,gBACzB2I,GADyB,IAC5C,2BAAmC,CAAC,IAAzBrK,EAAwB,QAC/B,GAAqB,MAAjBA,EAAKM,SAAkB,MAC3BN,EAAKK,SAAWoB,OAAOC,UACvB1B,EAAKM,UAAW,GAJwB,8BAM5C,OAAO+B,EAMX,GAFAiI,EAAQxJ,SAAU,EAClBuB,EAAoB1B,KAAK2J,GACrBA,IAAY9I,EAAS,CAAC,IAAD,gBACF6I,GADE,IACrB,2BAAmC,CAAC,IAAzBrK,EAAwB,QAC/B,GAAqB,MAAjBA,EAAKM,SAAkB,MAC3BN,EAAKK,SAAWoB,OAAOC,UACvB1B,EAAKM,UAAW,EAChBN,EAAKmC,cAAgBV,OAAOC,WALX,8BAOrB,OAAOW,EAEXtC,EAAoBuK,EAASrK,GAEjC,OAAOoC,EauK4BmI,CAAMxJ,EAAMO,EAAWC,GACpC,aAAd2C,Ed7MY,SAAClE,EAAOsB,EAAWC,GAGvCD,EAAUlB,SAAW,EAGrB,IAFA,IAAMgK,EAAiBtJ,EAAYd,GAC7BoC,EAAsB,GACrBgI,EAAezJ,OAAS,GAAG,CAC9BM,EAAUmJ,GAEV,IAAMC,EAAUD,EAAeE,QAE/B,GAAID,EAAQjK,WAAaoB,OAAOC,UAAW,CAAC,IAAD,gBACpB2I,GADoB,IACvC,2BAAmC,CAAC,IAAzBrK,EAAwB,QAC/B,GAAqB,MAAjBA,EAAKM,SAAkB,MAC3BN,EAAKK,SAAWoB,OAAOC,UACvB1B,EAAKM,UAAW,GAJmB,8BAMvC,OAAO+B,EAKX,GAHAiI,EAAQxJ,SAAU,EAClBuB,EAAoB1B,KAAK2J,GAErBA,IAAY9I,EAAS,CAAC,IAAD,gBACF6I,GADE,IACrB,2BAAmC,CAAC,IAAzBrK,EAAwB,QAC/B,GAAqB,MAAjBA,EAAKM,SAAkB,MAC3BN,EAAKK,SAAWoB,OAAOC,UACvB1B,EAAKM,UAAW,GAJC,8BAMrB,OAAO+B,EAEXtC,EAAoBuK,EAASrK,GAGjC,OADA8I,QAAQC,IAAI3G,GACLA,Ec4KkCoI,CAASzJ,EAAMO,EAAWC,GAC7C,yBAAd2C,EZ/MsB,SAAClE,EAAOsB,EAAWC,GACjDD,EAAUlB,SAAW,EACrBkB,EAAUT,SAAU,EAGpB,IAFA,IAAI4J,EAAY,CAACnJ,GACXc,EAAsB,GAJiC,aAMzD,IAAMT,EAAU8I,EAAUH,QAE1B,GADAlI,EAAoB1B,KAAKiB,GACrBA,IAAYJ,EAMZ,OALAkJ,EAAUR,SAAQ,SAAAlK,GACdA,EAAKc,SAAU,EACfd,EAAKM,SAAW,KAChBN,EAAKK,SAAWoB,OAAOC,aAErB,CAAN,EAAOW,GAEX,IAAMnC,EAAgBC,EAAiByB,EAAS3B,GAChDC,EAAcgK,SAAQ,SAAAlK,GAClBA,EAAKc,SAAU,EACfd,EAAKM,SAAWsB,EAChB5B,EAAKK,SAAWuB,EAAQvB,SAAW,KAEvCqK,EAAS,sBAAOA,GAAP,YAAqBxK,KAjB3BwK,EAAU9J,OAAS,GAAG,CAAC,IAAD,wCAmB7B,OAAOyB,EYuL8CsI,CAAmB3J,EAAMO,EAAWC,GAC/D,uBAAd2C,EAA2C/B,EAAiBpB,EAAMO,EAAWC,GAC9E,MAKLoJ,GAAa,SAAC9L,EAAKD,GAAN,MAAe,CACEC,IAAKA,EACLD,IAAKA,EACLO,QAASN,IAAQ2D,IAAY5D,IAAQ0D,GACrC1C,SAAUf,IAAQyJ,IAAa1J,IAAQwJ,GACvC3H,QAAQ,EACRI,SAAS,EACTvB,UAAW,QACXJ,SAAS,EACTkB,SAAUoB,OAAOC,UACjBS,cAAeV,OAAOC,YAGpDwH,GAAa,kBAAM2B,MAAM3E,IAAQ4E,OAAO7D,KAAI,SAAC8D,EAAMC,GAAP,OAfhCnM,EAe2DmM,EAfpDH,MAAM1E,IAAO2E,OAAO7D,KAAI,SAAC8D,EAAMjM,GAAP,OAAe8L,GAAW9L,EAAKD,MAA9D,IAAAA,MA6BZ6F,GAAQ,WACV,IADgB,EACVzD,EAAQ8D,SAASkG,uBAAuB,QAD9B,cAEGhK,GAFH,IAEhB,2BAA0B,CAAC,IAAhBjB,EAAe,QACtBA,EAAKiF,UAAUwE,OAAO,QACtBzJ,EAAKiF,UAAUwE,OAAO,QACtBzJ,EAAKiF,UAAUwE,OAAO,YALV,8BAOhBlC,GAAQ,SAAAvG,GAAI,OAAIA,EAAKiG,KAAI,SAAApI,GAAG,OAAIA,EAAIoI,KAAI,SAAAjH,GAAI,kCACnCA,GADmC,IAC7BU,QAAQ,EACfI,SAAS,EACTT,SAAUoB,OAAOC,UACjBS,cAAeV,OAAOC,qBAG9B,IAAMF,EAAUR,EAAKqH,IAAWE,IAChC/G,EAAQrC,SAAU,EAClB4F,SAASC,eAAT,UAA2BxD,EAAQ3C,IAAnC,YAA0C2C,EAAQ1C,MAAOqG,WAAW,GAAG7F,IAAM4L,EAE7EjD,GAAe,IAsCbkD,GAAqB,SAACtM,EAAKC,GAG7B,MAAO,CADgB,IAARD,EAAY,EAAKA,IAAQqH,GAAS,EAAIA,GAAS,EAAIrH,EAD3C,IAARC,EAAY,EAAKA,IAAQqH,GAAQ,EAAIA,GAAQ,EAAIrH,IAK9DgF,GAAc,SAAAL,GAChBiB,KACAwD,IAAc,GACd,IAAMkB,EAAUpI,EAAKiG,KAAI,SAAApI,GAAG,OAAIA,EAAIoI,KAAI,SAAAjH,GAAI,kCACnCA,GADmC,IAC7BU,QAAQ,EAAOI,SAAS,EAAOT,SAAUoB,OAAOC,mBA5C3C,SAAAV,GAAQ,MAEKmK,GAAmB5I,GAAUE,IAFlC,mBAEvBkH,EAFuB,KAEVyB,EAFU,OAGOD,GAAmB9C,GAAWE,IAHrC,mBAGvBqB,EAHuB,KAGTyB,EAHS,KAMzBD,IAAgBC,GAAgB1B,IAAgBC,IAC3CwB,EAAcjF,GAAQ,EAAGkF,GAAgB,EACxCA,GAAgB,GAGzBrK,EAAKuB,IAAUE,IAAUrD,SAAU,EACnC4B,EAAK2I,GAAayB,GAAahM,SAAU,EACzC4B,EAAKqH,IAAWE,IAAW1I,UAAW,EACtCmB,EAAK4I,GAAcyB,GAAcxL,UAAW,EAE5CsI,GAAYwB,GACZvB,GAAYgD,GACZ5C,GAAa6C,GACb/C,GAAasB,GAGb,IAAK,IAAIxG,EAAI,EAAGA,EAAI8C,GAAQ9C,IACxBpC,EAAKoC,GAAG+C,GAAQ,GAAGzF,QAAS,EAC5BM,EAAKoC,GAAG,GAAG1C,QAAS,EAGxB,IAAK,IAAI0C,EAAI,EAAGA,EAAI+C,GAAO/C,IACvBpC,EAAK,GAAGoC,GAAG1C,QAAS,EACpBM,EAAKkF,GAAS,GAAG9C,GAAG1C,QAAS,EAgBjC4K,CAAgBlC,GACH,cAAT3F,EAAsBnB,EAAgB8G,EAAS,EAAGlD,GAAS,EAAG,EAAGC,GAAQ,GTrTjE,SAAClG,EAAOsB,EAAWC,GACnC,IAAI+J,EACAC,EAEJ,GACID,EAAYvJ,KAAKkB,MAAMlB,KAAKgB,SAAW/C,EAAMW,QAC7C4K,EAAYxJ,KAAKkB,MAAMlB,KAAKgB,SAAW/C,EAAM,GAAGW,gBAEzC2K,EAAY,MAAQC,EAAY,IAI3C,IAFA,IAAMC,EAAW,CAACxL,EAAMsL,GAAWC,IAE1B3M,EAAM,EAAGA,EAAMoB,EAAMW,OAAQ/B,GAAO,EACzC,IAAK,IAAIC,EAAM,EAAGA,EAAMmB,EAAM,GAAGW,OAAQ9B,GAAO,EAC5CmB,EAAMpB,GAAKC,GAAK4M,aAAc,EAC9BzL,EAAMpB,GAAKC,GAAK4B,QAAS,EACzBT,EAAMpB,GAAKC,GAAK6M,SAAU,EACtB7M,EAAMmB,EAAM,GAAGW,OAAS,IACxBX,EAAMpB,GAAKC,EAAM,GAAG4B,QAAS,GAG7B7B,EAAMoB,EAAMW,OAAS,GAAGX,EAAMpB,EAAM,GAAGqL,SAAQ,SAAAlK,GAAI,OAAIA,EAAKU,QAAS,KAIjF,KAA2B,IAApB+K,EAAS7K,QAAc,CAC1B,IAAMgL,EAAe5J,KAAKkB,MAAMlB,KAAKgB,SAAWyI,EAAS7K,QACnDiL,EAAWJ,EAASG,GAC1BH,EAASK,OAAOF,EAAc,GAK9B,IAJA,IAAMrI,EAAYD,EAAarD,EAAO4L,GAGhCE,EAAkBxI,EAAU1C,QAAO,SAAAb,GAAI,OAAKA,EAAK0L,cAAgB1L,EAAK2L,WACrEI,EAAgBnL,QAAQ,CAC3B,IAAMoL,EAAYhK,KAAKkB,MAAMlB,KAAKgB,SAAW+I,EAAgBnL,QACvDZ,EAAO+L,EAAgBC,GAC7BhM,EAAK2L,SAAU,EACfI,EAAgBD,OAAOE,EAAW,GAClCP,EAAS9K,KAAKX,GAElB6L,EAASH,aAAc,EACvBG,EAASF,SAAU,EAEnB,IAAMM,EAAiB1I,EAAU1C,QAAO,SAAAb,GAAI,OAAIA,EAAK0L,eACrD,GAA8B,IAA1BO,EAAerL,OAAc,CAC7B,IAAMsL,EAAiBD,EAAejK,KAAKkB,MAAMlB,KAAKgB,SAAWiJ,EAAerL,SAC5EuL,OAAa,GAEbA,EADAD,EAAerN,MAAQgN,EAAShN,IAChBoB,EAAM4L,EAAShN,MAAMgN,EAAS/M,IAAMoN,EAAepN,KAAO,GAE1DmB,GAAO4L,EAAShN,IAAMqN,EAAerN,KAAO,GAAGgN,EAAS/M,MAE9D4M,aAAc,EAC5BS,EAAczL,QAAS,EAE3Ba,EAAUb,QAAS,EACnBc,EAAQd,QAAS,GS8PZ0L,CAAKhD,EAASA,EAAQ7G,IAAUE,IAAW2G,EAAQf,IAAWE,KACnEhB,EAAQ6B,GACRpD,EAASoD,EAvQK,GAwQdhE,YAAW,WACP8C,IAAc,KAzQJ,GA0QqB,GAAlB/B,GAAQD,IAAekD,EAAQxI,OAASwI,EAAQ,GAAGxI,UAmBlEyL,GAAmB,SAAAC,GACrBtI,EAAasI,IAQjB,OACI,qCACI,cAAC,EAAD,CAAKpI,WAAcA,GAAYJ,YAAe,SAAAL,GAAI,OAAIK,GAAYL,IAC7DO,aAAgB,SAAAsI,GAAO,OAAID,GAAiBC,IAC5CnI,UAAaA,EACbE,aAAgBA,GAChBD,mBAAsBA,GACtBE,UAhCK,WACdtD,EAAKqH,IAAWE,IAAWpJ,SAAU,EACrC+I,IAAc,GACd,IAEIvG,EAFEV,EAAQgJ,GAAwBjJ,EAAMA,EAAKuB,IAAUE,IAAWzB,EAAKqH,IAAWE,KACtFE,GAAgBxH,GAEH,MAATA,GAAkC,IAAjBA,EAAML,QF9TP,SAACK,EAAOU,EAAM4K,EAAW1H,GACjD,IADgE,IAAD,WACtDzB,GACDA,IAAMnC,EAAML,OACZwE,YAAW,WACC,MAARzD,GAAgBiD,EAAYjD,EAAMkD,KACnC0H,EAAYnJ,GAEdgC,YAAW,WACZQ,EAAiB3E,EAAMmC,MACxBmJ,EAAYnJ,IARVA,EAAI,EAAGA,GAAKnC,EAAML,OAAQwC,IAAM,EAAhCA,GE+TDoJ,CAAavL,EADbU,EAAOL,EAAgBN,EAAKuB,IAAUE,IAAWzB,EAAKqH,IAAWE,KAlRvD,GADA,IAsRdnD,YAAW,WACP8C,IAAc,GACdD,GAAe,KAvRL,GAwRChH,EAAML,QAAmB,MAARe,EAzRlB,GAyR6CA,EAAKf,OAAS,KAoBhE4D,YAzHO,WAChB,IAAM4E,EAAUpI,EAChBoI,EAAQc,SAAQ,SAAArL,GAAG,OAAIA,EAAIqL,SAAQ,SAAAlK,GAAI,OAAIA,EAAKU,QAAS,QACzD6G,EAAQ6B,GACR,IAJsB,EAIhBnI,EAAQ8D,SAASkG,uBAAuB,QAJxB,cAKHhK,GALG,IAKtB,2BAA0B,SACjBgE,UAAUwE,OAAO,SANJ,gCA0Hb/E,MAASA,MAEZgE,IAAmB,cAAC,EAAD,CAAOtB,YAhBhB,WAChBuB,IAAmB,GACnBT,IAAc,MAeV,qBAAKtJ,GAAK,OAAV,SACCoC,EAAKiG,KAAI,SAACpI,EAAKmM,GAAN,OACN,qBAAKjM,UAAY,MAAjB,SACKF,EAAIoI,KAAI,SAACjH,EAAMgL,GAAP,OACT,cAAC,EAAD,CACQlM,IAAOkB,EAAKlB,IACZD,IAAOmB,EAAKnB,IACZO,QAAWY,EAAKZ,QAChBS,SAAYG,EAAKH,SACjBa,OAAUV,EAAKU,OACfI,QAAWd,EAAKc,QAChBT,SAAYL,EAAKK,SACjB8B,cAAiBnC,EAAKmC,cACtB5C,UAAaS,EAAKT,UAClBJ,QAAWa,EAAKb,QAChBH,YAAemK,GACflK,UAAamL,GACblL,aAAgBwK,IAbTsB,OAFWA,aC1V/ByB,EATH,WAEV,OACE,8BACE,cAAC,EAAD,OCFNC,IAASC,OACP,cAAC,EAAD,IAAS5H,SAASC,eAAe,U","file":"static/js/main.2a2fe2f6.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/triangletwo-right.c7b52e1e.svg\";","export default __webpack_public_path__ + \"static/media/triangletwo-left.c7c58717.svg\";","export default __webpack_public_path__ + \"static/media/triangletwo-up.5c5fbe98.svg\";","export default __webpack_public_path__ + \"static/media/triangletwo-down.59a63b87.svg\";","export default __webpack_public_path__ + \"static/media/circle.a538beda.svg\";","import './Node.css'\nimport right from './triangletwo-right.svg'\nimport left from './triangletwo-left.svg'\nimport up from './triangletwo-up.svg'\nimport down from './triangletwo-down.svg'\nimport finish from './circle.svg'\n\nconst Node = props => {\n    const setDirection = () => {\n        if (props.direction === 'right') return right\n        if (props.direction === 'left') return left\n        if (props.direction === 'down') return down\n        return up\n    }\n    return  <div id = {`${props.row}-${props.col}`} \n                className = 'node'\n                onMouseDown = {() => props.onMouseDown(props.row, props.col)}\n                onMouseUp = {() => props.onMouseUp()}\n                onMouseEnter = {() => props.onMouseEnter(props.row, props.col)}>\n                {(props.isArrow || props.isStart) &&  <img class = 'start arrow zoom' src= {setDirection()} alt=\"img\"/>}\n                {(props.isFinish && !props.isArrow) &&  <img className = 'finish zoom' src= {finish} alt=\"img\"/>}\n            </div>\n}\n\nexport default Node","//Dijkstra algorithm (find shortest path between a starting node and the finishing node in the graph)\nexport const dijkstra = (graph, startNode, endNode) => {\n    // console.log(graph)\n    // console.log(startNode)\n    startNode.distance = 0\n    const unvisitedNodes = getAllNodes(graph)\n    const visitedNodesInOrder = []\n    while (unvisitedNodes.length > 0) {\n        sortNodes(unvisitedNodes)\n        //Get the node with smallest distance to the starting node\n        const minNode = unvisitedNodes.shift()\n        //Return if there is the smallest distance if infinity (a.k.a no path to the finish node)\n        if (minNode.distance === Number.MAX_VALUE) {\n            for (const node of unvisitedNodes) {\n                if (node.previous == null) break\n                node.distance = Number.MAX_VALUE\n                node.previous = false\n            }\n            return visitedNodesInOrder \n        }\n        minNode.visited = true\n        visitedNodesInOrder.push(minNode)\n        //Update the distance of all nodes adjacent to the current node in the unvisitedNodes\n        if (minNode === endNode) { \n            for (const node of unvisitedNodes) {\n                if (node.previous == null) break\n                node.distance = Number.MAX_VALUE\n                node.previous = false\n            }\n            return visitedNodesInOrder\n        }\n        updateAdjacentNodes(minNode, graph)    \n    }\n    console.log(visitedNodesInOrder)\n    return visitedNodesInOrder\n}\n\n//Update the distance of adjacent nodes when a node is visited\nconst updateAdjacentNodes = (node, graph) => {\n    const adjacentNodes = getAdjacentNodes(node, graph)\n    for (const adjacentNode of adjacentNodes) {\n        adjacentNode.distance = node.distance + 1\n        adjacentNode.previous = node\n    }\n}\n\n//Get all the adjacent nodes of a node that have not been visited yet \nconst getAdjacentNodes = (node, graph) => {\n    const X = node.row\n    const Y = node.col\n    const results = []\n    if (X > 0 && node.distance < graph[X-1][Y].distance && !graph[X-1][Y].isWall) results.push(graph[X-1][Y]) \n    if (X < graph.length - 1 && node.distance < graph[X+1][Y].distance && !graph[X+1][Y].isWall) results.push(graph[X+1][Y])\n    if (Y > 0 && node.distance < graph[X][Y-1].distance && !graph[X][Y-1].isWall) results.push(graph[X][Y-1])\n    if (Y < graph[0].length - 1 && node.distance < graph[X][Y+1].distance && !graph[X][Y+1].isWall) results.push(graph[X][Y+1])\n    return results.filter(node => !node.visited)\n}\n\n//Get all nodes in the grid \nconst getAllNodes = grid => {\n    const nodes = []\n    for (const row of grid) {\n        for (const node of row) nodes.push(node)\n    }\n    return nodes\n}\n\n//Arrange all the nodes in increasing order of distance\nconst sortNodes = nodes => nodes.sort((a,b) => a.distance - b.distance)\n\n//Get shortest path (use only after calling a pathfinding algorithm)\nexport const getShortestPath = (startNode, endNode) => {\n    if (endNode.previous === null || endNode.visited === false || endNode.distance === Number.MAX_VALUE) {\n        return null \n    }\n    const path = []\n    let current = endNode\n    while (true) {\n        path.unshift(current)\n        if (current === startNode) break\n        current = current.previous\n    } \n    return path\n}\n\n\n","export const aStar = (graph, startNode, endNode) => {\n    startNode.distance = 0\n    const unvisitedNodes = getAllNodes(graph)\n    const visitedNodesInOrder = []\n    for (const row of graph) {\n        for (const node of row) {\n            calculateEstimatedDistance(node, endNode)\n            calculateTotalDistance(node)\n        }\n    }\n    while (unvisitedNodes.length > 0) {\n        sortNodes(unvisitedNodes)\n        //Get the node with smallest distance to the starting node\n        const minNode = unvisitedNodes.shift()\n        //Return if there is the smallest distance if infinity (a.k.a no path to the finish node)\n        if (minNode.totalDistance === Number.MAX_VALUE) {\n            for (const node of unvisitedNodes) {\n                if (node.previous == null) break\n                node.distance = Number.MAX_VALUE\n                node.previous = false\n            }\n            return visitedNodesInOrder \n        }\n        //Update the distance of all nodes adjacent to the current node in the unvisitedNodes\n        //Put the visited node to the finished array\n        minNode.visited = true\n        visitedNodesInOrder.push(minNode)\n        if (minNode === endNode) {\n            for (const node of unvisitedNodes) {\n                if (node.previous == null) break\n                node.distance = Number.MAX_VALUE\n                node.previous = false\n                node.totalDistance = Number.MAX_VALUE\n            }\n            return visitedNodesInOrder \n        }\n        updateAdjacentNodes(minNode, graph)     \n    }\n    return visitedNodesInOrder\n}\n\n//Calculated the estimated distance from one node to the end node \nconst calculateEstimatedDistance = (node, endNode) => \n    node.estimatedDistance = Math.abs(node.row - endNode.row) + Math.abs(node.col - endNode.col)\n\n//Calculated the total distance from one node to the end node (total distance = distance to start + distance to finish)\nconst calculateTotalDistance = node => node.totalDistance = node.distance + node.estimatedDistance\n\n// const sortNodes = nodes => nodes.sort((a,b) => a.totalDistance - b.totalDistance)\nconst sortNodes = nodes => nodes.sort((a,b) =>\n    a.totalDistance - b.totalDistance === 0 ? a.estimatedDistance - b.estimatedDistance\n                                            : a.totalDistance - b.totalDistance )\n\nconst updateAdjacentNodes = (node, graph) => {\n    const adjacentNodes = getAdjacentNodes(node, graph)\n    for (const adjacentNode of adjacentNodes) {\n        adjacentNode.distance = node.distance + 1\n        calculateTotalDistance(adjacentNode)\n        adjacentNode.previous = node\n    }\n}\n\n//Get all the adjacent nodes of a node that have not been visited yet \nconst getAdjacentNodes = (node, graph) => {\n    const X = node.row\n    const Y = node.col\n    const results = []\n    if (X > 0 && node.distance < graph[X-1][Y].distance && !graph[X-1][Y].isWall) results.push(graph[X-1][Y]) \n    if (X < graph.length - 1 && node.distance < graph[X+1][Y].distance && !graph[X+1][Y].isWall) results.push(graph[X+1][Y])\n    if (Y > 0 && node.distance < graph[X][Y-1].distance && !graph[X][Y-1].isWall) results.push(graph[X][Y-1])\n    if (Y < graph[0].length - 1 && node.distance < graph[X][Y+1].distance && !graph[X][Y+1].isWall) results.push(graph[X][Y+1])\n    return results.filter(node => !node.visited)\n}\n\nconst getAllNodes = grid => {\n    const nodes = []\n    for (const row of grid) {\n        for (const node of row) nodes.push(node)\n    }\n    return nodes\n}\n\n\n","export const breadthFirstSearch = (graph, startNode, endNode) => {\n    startNode.distance = 0\n    startNode.visited = true\n    let callStack = [startNode]\n    const visitedNodesInOrder = []\n    while (callStack.length > 0) {\n        const current = callStack.shift()\n        visitedNodesInOrder.push(current)\n        if (current === endNode) {\n            callStack.forEach(node => {\n                node.visited = false\n                node.previous = null\n                node.distance = Number.MAX_VALUE\n            })\n            return visitedNodesInOrder \n        }\n        const adjacentNodes = getAdjacentNodes(current, graph)\n        adjacentNodes.forEach(node => {\n            node.visited = true\n            node.previous = current\n            node.distance = current.distance + 1\n        })\n        callStack = [...callStack, ...adjacentNodes]\n    }\n    return visitedNodesInOrder\n}\n\nconst getAdjacentNodes =(node, graph) => {\n    const X = node.row\n    const Y = node.col\n    const results = []\n    if (X > 0 && !graph[X-1][Y].visited && !graph[X-1][Y].isWall) results.push(graph[X-1][Y]) \n    if (Y < graph[0].length - 1 && !graph[X][Y+1].visited && !graph[X][Y+1].isWall) results.push(graph[X][Y+1])\n    if (X < graph.length - 1 && !graph[X+1][Y].visited && !graph[X+1][Y].isWall) results.push(graph[X+1][Y])\n    if (Y > 0 && !graph[X][Y-1].visited && !graph[X][Y-1].isWall) results.push(graph[X][Y-1])\n    return results.filter(node => !node.visited)\n}\n\n// console.log(breadthFirstSearch(graph, node1, node9))\n\n","export const depthFirstSearch = (graph, startNode, endNode) => {\n    startNode.distance = 0\n    startNode.visited = true\n    let visitedNodesInOrder = [startNode]\n    const adjacentNodes = getAdjacentNodes(startNode, graph)\n    if (adjacentNodes.length === 0 || startNode === endNode) return visitedNodesInOrder\n    for (const node of adjacentNodes) {\n        visitedNodesInOrder = [...visitedNodesInOrder, ...depthFirstSearch(graph, node, endNode)] \n        node.previous = startNode\n        node.distance = startNode.distance + 1\n        const len = visitedNodesInOrder.length\n        if (visitedNodesInOrder[len-1] === endNode) break\n    }\n    return visitedNodesInOrder\n} \n\n\nconst getAdjacentNodes =(node, graph) => {\n    const X = node.row\n    const Y = node.col\n    const results = []\n    if (X > 0 && !graph[X-1][Y].visited && !graph[X-1][Y].isWall) results.push(graph[X-1][Y]) \n    if (Y < graph[0].length - 1 && !graph[X][Y+1].visited && !graph[X][Y+1].isWall) results.push(graph[X][Y+1])\n    if (X < graph.length - 1 && !graph[X+1][Y].visited && !graph[X+1][Y].isWall) results.push(graph[X+1][Y])\n    if (Y > 0 && !graph[X][Y-1].visited && !graph[X][Y-1].isWall) results.push(graph[X][Y-1])\n    return results.filter(node => !node.visited)\n}\n\n"," export const recursiveDivide = (graph, startRow, endRow, startCol, endCol) => {\n    const height = endRow - startRow + 1\n    const width = endCol - startCol + 1\n    if ((width < 2 || height < 2) || (width === 2 && height === 2)) return \n    //Draw a vertical wall if the height is less than the width\n    if (width > height) verticalDivide(graph, startRow, endRow, startCol, endCol)\n    //Draw a horizontal wall if the height is less than the width\n    else if (width < height) horizontalDivide(graph, startRow, endRow, startCol, endCol)\n    //Choose randomly a horizontal or vertical wall to build if height equals width\n    else {\n        const randomDivision = Math.round(Math.random())\n        randomDivision ? horizontalDivide(graph, startRow, endRow, startCol, endCol) \n                       : verticalDivide(graph, startRow, endRow, startCol, endCol) \n    }\n}\n\nconst horizontalDivide = (graph, startRow, endRow, startCol, endCol) => {\n    const height = endRow - startRow + 1\n    const width = endCol - startCol + 1\n\n    let wallIndex = Math.floor(Math.random() * (height - 2)) + startRow + 1\n    if (height > 7) wallIndex = Math.floor(Math.random() * (height-6)) + startRow + 3\n    // else if (height === 6) wallIndex = Math.floor(Math.random() * 3) + startRow + 1\n    // else if (height === 5) \n\n    let isThrough = false\n    if ((endCol < graph[0].length - 1 && !graph[wallIndex][endCol + 1].isWall)\n        || graph[wallIndex][endCol].isStart || graph[wallIndex][endCol].isFinish) isThrough = true\n    else graph[wallIndex][endCol].isWall = true    \n\n    if ((startCol > 0 && !graph[wallIndex][startCol - 1].isWall)\n        || graph[wallIndex][startCol].isStart || graph[wallIndex][startCol].isFinish) isThrough = true\n    else graph[wallIndex][startCol].isWall = true\n\n    for (let i = startCol + 1; i < endCol; i++) {\n        if (graph[wallIndex][i].isStart || graph[wallIndex][i].isFinish) {\n            isThrough = true\n        } else graph[wallIndex][i].isWall = true\n    }\n    if (!isThrough) {\n        const gateIndex = Math.floor(Math.random() * width) + startCol\n        graph[wallIndex][gateIndex].isWall = false\n    }\n    //Draw a gate to get through the wall    \n    recursiveDivide(graph, startRow, wallIndex - 1, startCol, endCol)\n    recursiveDivide(graph, wallIndex + 1, endRow, startCol, endCol)   \n}\n\nconst verticalDivide = (graph, startRow, endRow, startCol, endCol) => {\n    const height = endRow - startRow + 1\n    const width = endCol - startCol + 1\n\n    let wallIndex = Math.floor(Math.random() * (width - 2)) + startCol + 1\n    if (width > 7) wallIndex = Math.floor(Math.random() * (width-6)) + startCol + 3\n\n    let isThrough = false\n    if ((startRow > 0 && !graph[startRow - 1][wallIndex].isWall)\n        || graph[startRow][wallIndex].isStart || graph[startRow][wallIndex].isFinish) isThrough = true\n    else graph[startRow][wallIndex].isWall = true\n    if ((endRow < graph.length - 1 && !graph[endRow + 1][wallIndex].isWall)\n        || graph[endRow][wallIndex].isStart || graph[endRow][wallIndex].isFinish) isThrough = true\n    else graph[endRow][wallIndex].isWall = true\n\n\n    for (let i = startRow + 1; i < endRow; i++) {\n        if (graph[i][wallIndex].isStart || graph[i][wallIndex].isFinish) isThrough = true\n        else graph[i][wallIndex].isWall = true\n    }\n    if (!isThrough) {\n        const gateIndex = Math.floor(Math.random() * height) + startRow\n        graph[gateIndex][wallIndex].isWall = false\n    }\n\n    //Draw a gate to get through the wall\n    recursiveDivide(graph, startRow, endRow, startCol, wallIndex - 1)\n    recursiveDivide(graph,startRow, endRow, wallIndex + 1, endCol)\n}\n\n\n\n","export const Prim = (graph, startNode, endNode) => {\n    let randomRow\n    let randomCol\n    \n    do {\n        randomRow = Math.floor(Math.random() * graph.length)\n        randomCol = Math.floor(Math.random() * graph[0].length)\n        \n    } while (!(randomRow % 2) || !(randomCol % 2))\n\n    const frontier = [graph[randomRow][randomCol]]\n\n    for (let row = 1; row < graph.length; row += 2) {\n        for (let col = 1; col < graph[0].length; col += 2) {\n            graph[row][col].isConnected = false\n            graph[row][col].isWall = false\n            graph[row][col].isFront = false\n            if (col < graph[0].length - 1)  {\n                graph[row][col + 1].isWall = true\n                // graph[row][col + 1].isFront\n            }\n            if (row < graph.length - 1) graph[row + 1].forEach(node => node.isWall = true)\n        }\n    } \n\n    while (frontier.length !== 0) {\n        const removedIndex = Math.floor(Math.random() * frontier.length)\n        const neighbor = frontier[removedIndex]\n        frontier.splice(removedIndex, 1)\n        const neighbors = getNeighbors(graph, neighbor)\n        //Add nodes that are not already connected or adjacent to connected nodes to frontier \n\n        const nodesToFrontier = neighbors.filter(node => !node.isConnected && !node.isFront)\n        while (nodesToFrontier.length) {\n            const nodeIndex = Math.floor(Math.random() * nodesToFrontier.length)\n            const node = nodesToFrontier[nodeIndex]\n            node.isFront = true\n            nodesToFrontier.splice(nodeIndex, 1)\n            frontier.push(node)\n        }\n        neighbor.isConnected = true\n        neighbor.isFront = false\n\n        const nodesToConnect = neighbors.filter(node => node.isConnected)\n        if (nodesToConnect.length !== 0) {\n            const randomNeighbor = nodesToConnect[Math.floor(Math.random() * nodesToConnect.length)]\n            let nodeToConnect\n            if (randomNeighbor.row === neighbor.row) {\n                nodeToConnect = graph[neighbor.row][(neighbor.col + randomNeighbor.col) / 2]\n            } else {\n                nodeToConnect = graph[(neighbor.row + randomNeighbor.row) / 2][neighbor.col]            \n            }\n            nodeToConnect.isConnected = true\n            nodeToConnect.isWall = false\n        }\n        startNode.isWall = false\n        endNode.isWall = false\n    }\n}\n\nconst getNeighbors = (graph, node) => {\n    const row = node.row\n    const col = node.col \n    const neighbors = []\n    if (row - 2 >= 0) neighbors.push(graph[row - 2][col])\n    if (row + 2 < graph.length) {\n        neighbors.push(graph[row + 2][col]) \n    }\n    if (col - 2 >= 0) neighbors.push(graph[row][col - 2])\n    if (col + 2 < graph[0].length) neighbors.push(graph[row][col + 2])\n    return neighbors\n}\n\n\n","import './button.css'\n\nconst Maze = props => {\n    return (\n        <div class=\"btn-group\">\n            <button type=\"button\"   \n                    disabled = {props.disabled}\n                    class= 'btn dropdown-toggle button btn-primary'\n                    data-bs-toggle=\"dropdown\" \n                    aria-expanded=\"false\">\n                Mazes\n            </button>\n            <ul class=\"dropdown-menu\">\n                <li class=\"dropdown-item\" onClick = {() => props.findNewMaze('Prim')}>Prim</li>\n                <li class=\"dropdown-item\" onClick = {() => props.findNewMaze('recursive')}> Recursive Division</li>\n            </ul>\n        </div> \n    )\n\n}\n\nexport default Maze","const Pathfinding = props => {\n    return (\n        <div class=\"btn-group\">\n            <button type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">\n                Algorithms\n            </button>\n            <ul class=\"dropdown-menu\">\n                <li class=\"dropdown-item\" onClick = {() => props.setAlgorithm('A*')}>\n                    A* Algorithm\n                </li>\n                <li class=\"dropdown-item\" onClick = {() => props.setAlgorithm('Dijkstra')}>\n                    Dijkstra's algorithm\n                </li>\n                <li class=\"dropdown-item\" onClick = {() => props.setAlgorithm('Breadth First Search')}>\n                    Breadth First Search\n                </li>\n                <li class = \"dropdown-item\" onClick = {() => props.setAlgorithm('Depth First Search')}>\n                    Depth First Search\n                </li>\n            </ul>\n        </div> \n    )\n}\n\nexport default Pathfinding","import './button.css'\n\nconst Visualize = props => {\n    return (\n        <button type=\"button\" \n                class= {`btn ${props.isDisabled || props.algorithm.length === 0 ? 'red' : 'btn-primary'}`}         \n                disabled = {props.isDisabled || props.algorithm.length === 0} \n                onClick = {() => {\n                        props.removeVisitedNodes(props.visitedNodes)\n                        props.visualize()}}>\n                {props.algorithm.length === 0 ? \"Pick an algorithm\" : `Visualize ${props.algorithm}!`}\n        </button>\n    )\n}\n\nexport default Visualize ","import './button.css'\n\nconst Clear = props => {\n    return (\n        <button class = 'button' type=\"button\" \n            class= {`btn ${props.isDisabled ? 'red' : 'btn-primary'}`}         \n            disabled = {props.isDisabled}\n            onClick = {() => props.removeWalls()}>Clear Wall\n        </button>\n    )\n}\n\nexport default Clear","import './button.css'\n\nconst Reset = props => {\n    return (\n        <button type= \"button\" \n                class= {`btn 'button' ${props.isDisabled ? 'red' : 'btn-primary'}`}         \n                disabled = {props.isDisabled}\n                onClick = {() => {\n                    props.reset()}}>\n                Clear Grid\n        </button>\n    )\n}\n\nexport default Reset","import Maze from './button/Mazes'\nimport Pathfinding from './button/Pathfinding'\nimport Visualize from './button/Visualize'\nimport Clear from './button/Clear'\nimport Reset from './button/Reset'\n\nconst Nav = props => {\n    return (\n        <nav class= \"navbar navbar-dark bg-primary\">\n            <div class=\"container-fluid navbar-brand\">\n                Pathfinding Visualizer\n            </div>\n            <Maze disabled = {props.isDisabled} findNewMaze = {props.findNewMaze}/>\n            <Pathfinding setAlgorithm = {props.setAlgorithm}/>\n            <Visualize  removeVisitedNodes = {props.removeVisitedNodes}\n                        isDisabled = {props.isDisabled}\n                        algorithm = {props.algorithm}\n                        visualize = {props.visualize}\n                        visitedNodes = {props.visitedNodes}/>\n            <Clear isDisabled = {props.isDisabled} removeWalls = {props.removeWalls}/>\n            <Reset  isDisabled = {props.isDisabled}\n                    reset = {props.reset} />\n        </nav>\n    )\n}\n\nexport default Nav","import right from './node/triangletwo-right.svg'\nimport left from './node/triangletwo-left.svg'\nimport up from './node/triangletwo-up.svg'\nimport down from './node/triangletwo-down.svg'\n\n//Animate the nodes visited in the process of finding the shortest path\nexport const animateNodes = (nodes, path, nodeSpeed, pathSpeed) => {\n    for (let i = 0; i <= nodes.length; i++) {\n        if (i === nodes.length) {\n            setTimeout(() => {\n                path != null && animatePath(path, pathSpeed)\n            }, nodeSpeed * i)\n        }\n        else setTimeout(() => {\n            drawVisitedNodes(nodes[i])\n        }, nodeSpeed * i);\n    }\n}\n\n//Animate the shortest path\nconst animatePath = (path, pathSpeed) => {\n    const pathLength = path.length\n    const startNode = document.getElementById(`${path[0].row}-${path[0].col}`)\n    startNode.classList.add('path')\n    if (path[1].row > path[0].row) startNode.childNodes[0].src = down\n    else if (path[1].row < path[0].row) startNode.childNodes[0].src = up\n    else if (path[1].col > path[0].col) startNode.childNodes[0].src = right\n    else if (path[1].row < path[0].row) startNode.childNodes[0].src = left\n  \n    for (let i = 1; i < pathLength - 1; i++) {\n        setTimeout(() => {\n            drawPath(path[i])\n        }, pathSpeed * i);\n    }\n    const endNode = path[pathLength - 1]\n    const endNodeOnGrid = document.getElementById(`${endNode.row}-${endNode.col}`)\n    setTimeout(() => {\n        endNodeOnGrid.classList.add('path')\n        endNodeOnGrid.childNodes[0].src = chooseArrow(endNode.previous, endNode)\n        const nearEndNode = endNode.previous\n        const nearEndNodeOnGrid = document.getElementById(`${nearEndNode.row}-${nearEndNode.col}`)\n        nearEndNodeOnGrid.removeChild(nearEndNodeOnGrid.childNodes[0])\n    }, pathSpeed * (pathLength - 1));\n}\n\n//Choose the direction of the arrow (left, right, up, or down) \nexport const chooseArrow = (previousNode, node) => {\n    const current = document.getElementById(`${node.row}-${node.col}`)\n    if (node.row > previousNode.row) return down\n    if (node.row < previousNode.row) return up\n    if (node.col > previousNode.col) return right\n    return left\n}\n\nexport const drawVisitedNodes = node => {\n    document.getElementById(`${node.row}-${node.col}`).classList.add('visited')\n}\n\n//Draw a node in the path \nexport const drawPath = node => {\n    document.getElementById(`${node.row}-${node.col}`).classList.add('path')\n    const elem = document.createElement(\"img\");\n    elem.className = 'arrow'\n    elem.src = chooseArrow(node.previous, node)\n    document.getElementById(`${node.row}-${node.col}`).appendChild(elem)\n    if (!node.previous.isStart) {\n        const previousNode = document.getElementById(`${node.previous.row}-${node.previous.col}`)\n        previousNode.removeChild(previousNode.childNodes[0])\n    }    \n}\n\n//Draw the border of the maze\nconst drawBorder = (grid, mazeSpeed) => {\n    const HEIGHT = grid.length\n    const WIDTH = grid[0].length\n    for (let i = 0; i < HEIGHT; i++) {\n        setTimeout(() => {\n            document.getElementById(`${i}-${WIDTH - 1}`).classList.add('wall')\n\n        }, mazeSpeed * (WIDTH + i))       \n        setTimeout(() => {\n            document.getElementById(`${HEIGHT- 1 - i}-0`).classList.add('wall')\n        }, mazeSpeed * (2 * WIDTH + HEIGHT + i))\n    }\n\n    for (let i = 0; i < WIDTH; i++) {\n        grid[HEIGHT - 1][i].isWall = true\n        setTimeout(() => {\n            document.getElementById(`0-${i}`).classList.add('wall')\n        }, mazeSpeed * i)  \n        setTimeout(() => {\n            document.getElementById(`${HEIGHT-1}-${WIDTH - 1 - i}`).classList.add('wall')\n        }, mazeSpeed * (HEIGHT + WIDTH + i))        \n    }\n}\n\n//Draw maze\nexport const drawMaze = (grid, mazeSpeed) => {\n    const HEIGHT = grid.length\n    const WIDTH = grid[0].length\n    drawBorder(grid, mazeSpeed)\n    setTimeout(() => {\n        for (let i = 1; i < grid.length - 1; i ++) {\n            for (let j = 1; j < grid[i].length - 1; j++) {\n                 if (grid[i][j].isWall) {\n                     setTimeout(() => {\n                         document.getElementById(`${i}-${j}`).classList.add('wall')\n                     }, mazeSpeed * (j * grid.length + i))\n                 }\n            }\n        }\n    }, (WIDTH + HEIGHT) * mazeSpeed * 2)\n}","import { useState } from \"react\"\nimport './guide.css'\n\nconst Guide = props => {\n    const [step, setStep] = useState(0)\n\n    const headers = [\n                        'Welcome to Pathfinding Visualizer!', \n                        'Introduction', \n                        'Pick an algorithm', \n                        'Graph Theory 101' ,\n                        \"Ready to visualize!\", \n                        'Move your nodes',\n                        'Add more obstacles!',\n                        'Clean up your space',\n                        'This feafure will aMAZE you!', 'The end.'\n    ]\n\n    const leads = [\n        'This short guide will show you all the cool features',\n        'Pathfinding algorithms are used to find the shortest path from one vertex to another in a graph.',\n        'Click the \"algorithms\" button to expand the options.',\n        \"Let's meet our famous pathfinding algorithms\",\n        'Click the \"visualize\" button to run the algorithm.',\n        'Click the start/end node and move your mouse to a new position.',\n        'A plain grid is just too boring! Click and drag all over the grid to add or remove more walls',\n        'Click the \"clear wall\" or \"clear grid\" button to restart',\n        'Click the \"maze\" button to select a maze for the grid.',\n        'Time to explore some algorithms! Have fun with the magic of graph theory.' \n    ]\n\n    const guides =  [\n                        \"Don't worry if you have no idea what pathfinding is! You can think of this visualization tool as a fun simulation game.\",\n                        \"But it is too confusing with all the dots going on! Don't run away because we could learn it the fun way.\",\n                        'There are four algorithms in total. Each of them is unique and you can see that demonstrated clearly in the visualization process',\n                        {\n                            'A Star': 'Maybe the most popular pathfinding algorithm. Use heuristics to find the path within a short amount of time',\n                            'Dijkstra': 'A classic algorithm that guarantees the shortest path.',\n                            'Breadth First Search': 'Explore the adjacent nodes first. Guarantee the shortest path.',\n                            'Depth First Search': 'Dive in as deep as possible. Not guarantee the shortest path'\n                        },\n                        'Blue indicates that the node has been visited in the pathfinding process. Yellow indicates the actual path from the start to the end point',\n                        'If you place it on a wall, that wall will be removed. If you already run an algorithm, moving the nodes around will show the new path.',\n                        'Walls are impenetrable. If your node meets a wall in the pathfinding process, it will have to find a new (and longer) path',\n                        '\"Clear wall\" will remove all the existing walls on the grid. \"Clear Grid\" will delete everything, including the visited nodes and path.',\n                        'There are two types of mazes for you (Prim is also an important algorithm in graph theory). The process of creating a maze will start immediately.',\n                        'This project is (indirectly) the outcome of my Foundations of Computation class. A huge thanks to Professor Scott Thede for his Graph Theory lectures.'\n                    ]  \n    \n    const generateHeaders = step => <h1 className = 'headers'>{headers[step]}</h1>\n\n    const generateLead = step => <p className = 'leads'>{leads[step]}</p>\n\n    const generateGuide = step => {\n        if (typeof guides[step] === 'string') return <p className = 'guides'>{guides[step]}</p>\n        return Object.entries(guides[step]).map(guide =>\n        <div className = 'guides'>\n            <b>{guide[0]}:</b> {guide[1]}\n        </div>)\n    }\n\n    return (\n        <div className = 'guide'>\n            <p className = 'index'>{`${step + 1}/${headers.length}`}</p>\n            {generateHeaders(step)}\n            {generateLead(step)}\n            {generateGuide(step)}\n            <button type= \"button\" \n                    className= \"btn btn-primary skip\"\n                    onClick = {() => props.finishGuide()}>\n                Skip\n            </button>\n            {step < headers.length - 1  ?   <button type = 'button' \n                                                   className=\"btn btn-primary next\"\n                                                   onClick = {() => setStep(prev => prev + 1)}>\n                                                Next\n                                            </button>\n                                        :   <button type= \"button\" \n                                                    className= \"btn btn-primary next\"\n                                                    onClick = {() => props.finishGuide()}>\n                                                Finish\n                                            </button>} \n            {step > 0 && <button type = 'button'\n                                 onClick = {() => setStep(prev => prev - 1)}\n                                 className=\"btn btn-primary previous\">Previous</button>}\n        </div>\n    )\n}\n\nexport default Guide","import { useEffect, useState} from 'react'\nimport Node from './node/Node'\nimport {getShortestPath, dijkstra} from './algorithms/pathfinding/Dijkstra.js'\nimport {aStar} from './algorithms/pathfinding/A*'\nimport {breadthFirstSearch} from './algorithms/pathfinding/Bfs'\nimport {depthFirstSearch} from './algorithms/pathfinding/Dfs'\nimport {recursiveDivide} from './algorithms/mazes/Recursive'\nimport {Prim} from './algorithms/mazes/Prim'\nimport Nav from './nav/Nav'\nimport {animateNodes, drawVisitedNodes, chooseArrow, drawMaze} from './Animations'\nimport Guide from './guide/Guide'\nimport './styles.css'\nimport circle from './node/circle.svg'\n\nconst Visualizer = () => {  \n    const [grid, setGrid] = useState([[]])  \n        \n    const [isPressed, setIsPressed] = useState(false)\n\n    const [previousWall, setPreviousWall] = useState(null)\n\n    const [startButton, setStartButton] = useState(false)\n    const [finishButton, setFinishButton] = useState(false)\n\n    const [isPathFound, setIsPathFound] = useState(false)\n\n    const [algorithm, setAlgorithm] = useState('')\n\n    //The status to disable all activities on the grid (draw maze, draw or remove walls, \n    //move node, visualize the path...) if the visualization is running or the maze is being drawn\n    const [isDisabled, setIsDisabled] = useState(true)\n\n    const [startRow, setStartRow] = useState(3)\n    const [startCol, setStartCol] = useState(1)\n    const [finishRow, setFinishRow] = useState(3)\n    const [finishCol, setFinishCol] =  useState(7)\n\n    const [visitedNodes, setVisitedNodes] = useState([])\n\n    const [isGuideFinished, setIsGuideFinished] = useState(false)\n\n    let WIDTH = Math.floor(document.documentElement.clientWidth/25)\n\n    if (!(WIDTH % 2)) WIDTH += 1\n\n    let HEIGHT = Math.floor(document.documentElement.clientHeight/40)\n    \n    if (!(HEIGHT % 2)) HEIGHT += 1\n\n    const mazeSpeed = 5\n    const pathSpeed = 50\n    const nodeSpeed = 10\n\n    console.log(document.documentElement.clientWidth/25)\n\n    useEffect(() => setGrid(createGrid()),[])\n    // grid != null && console.log(grid)\n    const handleMouseDown = (row, col) => {\n        let newGrid = grid\n\n        //Check if the start or the finish node is pressed\n        const isStartNode = row === startRow && col === startCol\n        const isEndNode = row === finishRow && col === finishCol\n        \n\n        //Draw or remove wall if the node is neither start node nor finish node\n        if (!(isStartNode || isEndNode || isDisabled)) {         \n            const classes = document.getElementById(`${row}-${col}`).classList\n            classes.contains('wall') ? classes.remove('wall') : classes.add('wall')\n            newGrid[row][col].isWall = !newGrid[row][col].isWall\n        }\n        setIsPressed(!(isStartNode || isEndNode || isDisabled))\n        //Move the start node\n        let newIsDisabled = false\n        setStartButton(prev => {\n            if (prev) {\n                const classes = document.getElementById(`${row}-${col}`).classList\n                classes.remove('wall')\n                newGrid[row][col].isWall = false\n                return !prev\n            }\n            return (isStartNode && !isDisabled) \n        })\n\n        //Move the finish node\n        setFinishButton(prev => {\n            if (prev) {\n                const classes = document.getElementById(`${row}-${col}`).classList\n                classes.remove('wall')\n                newGrid[row][col].isWall = false\n                return !prev\n            }\n            return (isEndNode && !isDisabled)\n        })\n        // newGrid[startRow][startCol].isArrow = true\n        setGrid(newGrid)\n        setIsDisabled(newIsDisabled)\n        setPreviousWall(null)\n    }\n\n    const handleMouseEnter = (row, col) => { \n        //Check is the node is start or finish \n        let newGrid = grid\n        const isStartNode = row === startRow && col === startCol\n        const isEndNode = row === finishRow && col === finishCol\n\n        //Add or remove wall if the node is neither start nor finish\n        if (isPressed && !(isStartNode || isEndNode)) {\n            const classes = document.getElementById(`${row}-${col}`).classList\n            classes.contains('wall') ? classes.remove('wall') : classes.add('wall')\n            newGrid[row][col].isWall = !newGrid[row][col].isWall\n        } \n\n        //Update start node\n        const newStartRow = startButton && !isEndNode ? row : startRow\n        const newStartCol = startButton && !isEndNode  ? col : startCol\n        setStartCol(newStartCol)\n        setStartRow(newStartRow)\n        if (newGrid[0].length > 0 && !newGrid[row][col].isStart) {\n            newGrid[startRow][startCol].isStart = !(startButton && !isEndNode)\n            newGrid[row][col].isStart = startButton && !isEndNode    \n        }\n        \n        //Update finish node\n        const newFinishRow = finishButton && !isStartNode ? row : finishRow\n        const newFinishCol = finishButton && !isStartNode ? col : finishCol \n        setFinishCol(newFinishCol)\n        setFinishRow(newFinishRow)\n        if (newGrid[0].length > 0 && !newGrid[row][col].isFinish) {\n            newGrid[finishRow][finishCol].isFinish = !(finishButton && !isStartNode)\n            newGrid[row][col].isFinish = finishButton && !isStartNode\n        }\n        \n        //Find a new path if the start or finish node is moved to a new place\n        let newVisitedNodes = visitedNodes\n        if (startButton || finishButton) {\n            let newPreviousWall = null\n            if (previousWall != null) {\n                previousWall.isWall = true\n                document.getElementById(`${previousWall.row}-${previousWall.col}`).classList.add('wall')\n            }\n            if (newGrid[row][col].isWall) {\n                newPreviousWall = newGrid[row][col]\n                document.getElementById(`${row}-${col}`).classList.remove('wall')\n                newGrid[row][col].isWall = false\n            } \n            setPreviousWall(newPreviousWall)\n            if (isPathFound) {\n                //Remove the current visited nodes and path\n                newVisitedNodes = removeVisitedNodes(newVisitedNodes)        \n                //Find new visited nodes and path\n                let newStartNode\n                let newEndNode\n                newGrid[finishRow][finishCol].isArrow = false\n                newStartNode = startButton ? newGrid[row][col] : newGrid[startRow][startCol] \n                newEndNode = startButton ? newGrid[finishRow][finishCol] : newGrid[row][col]\n                newVisitedNodes =  runPathfindingAlgorithm(newGrid, newStartNode, newEndNode)\n                newVisitedNodes.forEach(node => drawVisitedNodes(node))\n                const newPath = getShortestPath(newStartNode, newEndNode)\n                if (newPath !== null) {\n                    newPath.forEach(node => {\n                        document.getElementById(`${node.row}-${node.col}`).classList.add('path')\n                    })\n                    // props.direction\n                    if (newPath[1].row > newPath[0].row) newPath[0].direction = 'down'\n                    else if (newPath[1].row < newPath[0].row) newPath[0].direction = 'up'\n                    else if (newPath[1].col > newPath[0].col) newPath[0].direction = 'right'\n                    else if (newPath[1].col < newPath[0].col) newPath[0].direction = 'left'\n\n                    const endNode = newPath[newPath.length - 1]\n                    const nearEndNode = endNode.previous\n                    endNode.isArrow = true\n                    if (endNode.row > nearEndNode.row) endNode.direction = 'down'\n                    else if (endNode.row < nearEndNode.row) endNode.direction = 'up'\n                    else if (endNode.col > nearEndNode.col) endNode.direction = 'right'\n                    else if (endNode.col < nearEndNode.col) endNode.direction = 'left'\n                }\n            }\n        } \n        setVisitedNodes(newVisitedNodes)\n        setGrid(newGrid)\n    }\n\n    //Remove all the current visited nodes\n    const removeVisitedNodes = visitedNodes => {\n        visitedNodes.forEach(\n            node => {\n                const classes = document.getElementById(`${node.row}-${node.col}`).classList\n                classes.remove('visited')\n                classes.remove('path')\n            })   \n        visitedNodes.forEach(node => {\n            node.visited  = false\n            node.distance = Number.MAX_VALUE\n            node.previous = null\n            })\n        return []\n    }\n\n    const handleMouseUp = () => {\n        setIsPressed(false)     \n    }\n\n    //Run the algorithm that the user chooses\n    const runPathfindingAlgorithm = (grid, startNode, endNode) => {\n        if (algorithm === 'A*') return aStar(grid, startNode, endNode)\n        if (algorithm === 'Dijkstra') return dijkstra(grid, startNode, endNode)\n        if (algorithm === 'Breadth First Search') return breadthFirstSearch(grid, startNode, endNode)\n        else if(algorithm === \"Depth First Search\") return depthFirstSearch(grid, startNode, endNode)\n        return null\n    } \n\n    const createRow = row => Array(WIDTH).fill().map((item, col) => createNode(col, row))\n\n    const createNode = (col, row) => ({\n                                        col: col, \n                                        row: row, \n                                        isStart: col === startCol && row === startRow,\n                                        isFinish: col === finishCol && row === finishRow,\n                                        isWall: false,\n                                        visited: false,\n                                        direction: 'right',\n                                        isArrow: false,\n                                        distance: Number.MAX_VALUE,\n                                        totalDistance: Number.MAX_VALUE\n                                      })\n\n    const createGrid = () => Array(HEIGHT).fill().map((item, index) => createRow(index))\n\n    //Remove all walls\n    const removeWalls = () => {\n        const newGrid = grid\n        newGrid.forEach(row => row.forEach(node => node.isWall = false))\n        setGrid(newGrid)\n        const nodes = document.getElementsByClassName('node')\n        for (const node of nodes) {\n            node.classList.remove('wall')\n        }\n    }    \n\n    //Remove all the visited nodes and the shortest path found (equivalent to reset)\n    const reset = () => {\n        const nodes = document.getElementsByClassName('node')\n        for (const node of nodes) {\n            node.classList.remove('wall')\n            node.classList.remove('path')\n            node.classList.remove('visited')\n        }\n        setGrid(grid => grid.map(row => row.map(node => \n            ({...node, isWall: false, \n                visited: false,\n                distance: Number.MAX_VALUE,\n                totalDistance: Number.MAX_VALUE\n            }))))\n\n        const endNode = grid[finishRow][finishCol]\n        endNode.isArrow = false\n        document.getElementById(`${endNode.row}-${endNode.col}`).childNodes[0].src = circle\n\n        setIsPathFound(false)\n    }\n\n    //Set all the nodes on the border to walls \n    const setBorderToWall = grid => {\n        //Move the start or finish node if it is on the border\n        let [newStartRow, newStartCol] = moveNodeFromBorder(startRow, startCol)\n        let [newFinishRow, newFinishCol] = moveNodeFromBorder(finishRow, finishCol)\n\n        //Move the finish node if the start and finish node are at the same position \n        if(newStartCol === newFinishCol && newStartRow === newFinishRow) {\n            if (newStartCol < WIDTH - 2) newFinishCol += 1\n            else newFinishCol -= 1\n        }\n\n        grid[startRow][startCol].isStart = false\n        grid[newStartRow][newStartCol].isStart = true\n        grid[finishRow][finishCol].isFinish = false\n        grid[newFinishRow][newFinishCol].isFinish = true\n\n        setStartRow(newStartRow)\n        setStartCol(newStartCol)\n        setFinishCol(newFinishCol)\n        setFinishRow(newFinishRow)\n\n        //Set the wall to true for all border nodes\n        for (let i = 0; i < HEIGHT; i++) {\n            grid[i][WIDTH - 1].isWall = true\n            grid[i][0].isWall = true\n        }\n\n        for (let i = 0; i < WIDTH; i++) {\n            grid[0][i].isWall = true\n            grid[HEIGHT - 1][i].isWall = true\n        }\n    }\n\n    //Set new row and col for the start or finish node to the adjacent position if it is on the border\n    const moveNodeFromBorder = (row, col) => {\n        const newCol = col === 0 ? 1 : (col === WIDTH - 1 ? WIDTH - 2 : col)\n        const newRow = row === 0 ? 1 : (row === HEIGHT - 1 ? HEIGHT - 2 : row)\n        return [newRow, newCol]\n    }\n\n    const findNewMaze = type => {\n        reset()\n        setIsDisabled(true)\n        const newGrid = grid.map(row => row.map(node => \n            ({...node, isWall: false, visited: false, distance: Number.MAX_VALUE})))\n        setBorderToWall(newGrid)\n        if (type === 'recursive') recursiveDivide(newGrid, 1, HEIGHT - 2, 1, WIDTH - 2)\n        else Prim(newGrid, newGrid[startRow][startCol], newGrid[finishRow][finishCol])\n        setGrid(newGrid)\n        drawMaze(newGrid, mazeSpeed)\n        setTimeout(() => {\n            setIsDisabled(false)\n        }, mazeSpeed * ((WIDTH + HEIGHT) * 2 + (newGrid.length * newGrid[0].length)))\n    }\n\n    const visualize = () => {\n        grid[finishRow][finishCol].isArrow = false\n        setIsDisabled(true)\n        const nodes = runPathfindingAlgorithm(grid, grid[startRow][startCol], grid[finishRow][finishCol])\n        setVisitedNodes(nodes)\n        let path\n        if (nodes != null && nodes.length !== 0) {\n            path = getShortestPath(grid[startRow][startCol], grid[finishRow][finishCol])\n            animateNodes(nodes, path, nodeSpeed, pathSpeed)\n        }\n        setTimeout(() => {\n            setIsDisabled(false)\n            setIsPathFound(true)\n        }, nodeSpeed * nodes.length + ( path != null ? pathSpeed * path.length : 0));\n    }\n\n    const setAlgorithmName = newName => {\n        setAlgorithm(newName)\n    }\n\n    const finishGuide = () => {\n        setIsGuideFinished(true)\n        setIsDisabled(false)\n    }\n\n    return (\n        <>     \n            <Nav isDisabled = {isDisabled} findNewMaze = {type => findNewMaze(type)}\n                 setAlgorithm = {newName => setAlgorithmName(newName)}\n                 algorithm = {algorithm}\n                 visitedNodes = {visitedNodes}\n                 removeVisitedNodes = {removeVisitedNodes}\n                 visualize = {visualize}\n                 removeWalls = {removeWalls}\n                 reset = {reset}>\n            </Nav>\n            {!isGuideFinished && <Guide finishGuide = {finishGuide}/>}\n            <div id = 'grid'>\n            {grid.map((row, index) =>\n                <div className = 'row' key = {index}>\n                    {row.map((node, index) =>\n                    <Node   key = {index}\n                            col = {node.col}\n                            row = {node.row}\n                            isStart = {node.isStart}\n                            isFinish = {node.isFinish}\n                            isWall = {node.isWall}\n                            visited = {node.visited}\n                            distance = {node.distance}\n                            totalDistance = {node.totalDistance}\n                            direction = {node.direction}\n                            isArrow = {node.isArrow}\n                            onMouseDown = {handleMouseDown}\n                            onMouseUp = {handleMouseUp}\n                            onMouseEnter = {handleMouseEnter}/>\n                            )\n                    }\n                </div>)}        \n            </div>\n        </>\n    )\n}\n\nexport default Visualizer","import Visualizer from './Visualizer'\n\nconst App = () => {\n\n  return (\n    <div>\n      <Visualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App.jsx';\n\nReactDOM.render(\n  <App />, document.getElementById('root')\n);\n"],"sourceRoot":""}